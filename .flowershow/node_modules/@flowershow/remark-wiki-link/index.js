import { toMarkdown } from 'mdast-util-wiki-link';
import fs from 'fs';
import path from 'path';

function _iterableToArrayLimit(arr, i) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s,
      _e,
      _x,
      _r,
      _arr = [],
      _n = !0,
      _d = !1;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i) return;
        _n = !1;
      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

function wikiLinkTransclusionFormat(extension) {
  var transclusionFormats = [/\.jpe?g$/, /\.a?png$/, /\.webp$/, /\.avif$/, /\.gif$/, /\.svg$/, /\.bmp$/, /\.ico$/, /\.pdf$/];
  var supportedFormat = extension.match(transclusionFormats.filter(function (r) {
    return extension.match(r);
  })[0])[0];
  var strippedExtension = extension.match(/\.[0-9a-z]{1,4}$/gi);
  if (!supportedFormat) return [false, strippedExtension && strippedExtension[0].replace(".", "")];
  return [true, supportedFormat.replace(".", "")];
}
function fromMarkdown() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var permalinks = opts.permalinks || [];
  var defaultPageResolver = function defaultPageResolver(name) {
    return [name.replace(/ /g, "-").toLowerCase()];
  };
  var pageResolver = opts.pageResolver || defaultPageResolver;
  var newClassName = opts.newClassName || "new";
  var wikiLinkClassName = opts.wikiLinkClassName || "internal";
  var defaultHrefTemplate = function defaultHrefTemplate(permalink) {
    if (permalink.startsWith("#")) return permalink;
    return "/".concat(permalink);
  };
  var hrefTemplate = opts.hrefTemplate || defaultHrefTemplate;
  function enterWikiLink(token) {
    this.enter({
      type: "wikiLink",
      isType: token.isType ? token.isType : null,
      value: null,
      data: {
        alias: null,
        permalink: null,
        exists: null
      }
    }, token);
  }
  function top(stack) {
    return stack[stack.length - 1];
  }
  function exitWikiLinkAlias(token) {
    var alias = this.sliceSerialize(token);
    var current = top(this.stack);
    current.data.alias = alias;
  }
  function exitWikiLinkTarget(token) {
    var target = this.sliceSerialize(token);
    var current = top(this.stack);
    current.value = target;
  }
  function exitWikiLink(token) {
    var wikiLink = this.exit(token);
    // if (opts.markdownFolder && wikiLink.value.includes(`${opts.markdownFolder}/`)) {
    //   const [, ...value] = wikiLink.value.split(`${opts.markdownFolder}/`)
    //   wikiLink.value = value
    // }
    var wikiLinkTransclusion = wikiLink.isType === "transclusions";
    var pagePermalinks = pageResolver(wikiLink.value);
    var permalink = pagePermalinks.find(function (p) {
      var heading = "";
      if (!wikiLinkTransclusion && p.match(/#/)) {
        var _p$split = p.split("#");
        var _p$split2 = _slicedToArray(_p$split, 2);
        heading = _p$split2[1];
      }
      var link = heading ? p.replace("#".concat(heading), "") : p;
      return permalinks.indexOf(link) !== -1;
    });
    var exists = permalink !== undefined;
    if (!exists) {
      permalink = pagePermalinks[0];
    }
    var regex = /\/?index(?![\w\S])|\/?index(?=#)/g;
    if (!wikiLinkTransclusion && permalink.match(regex)) {
      permalink = permalink.replace(regex, "");
    }
    var displayName;
    var transclusionFormat;
    if (wikiLinkTransclusion) {
      transclusionFormat = wikiLinkTransclusionFormat(wikiLink.value);
      if (!transclusionFormat[0]) {
        displayName = "Document type ".concat(transclusionFormat[1] ? transclusionFormat[1].toUpperCase() : null, " is not yet supported for transclusion");
        console.warn(displayName);
        wikiLink.data.hName = "span";
        wikiLink.data.hChildren = [{
          type: "text",
          value: displayName
        }];
      } else {
        var _regex = new RegExp("".concat(transclusionFormat[1], "$"), "g");
        displayName = wikiLink.value.replace(_regex, "");
        if (transclusionFormat[1] === "pdf") {
          wikiLink.data.hName = "embed";
        } else {
          wikiLink.data.hName = "img";
        }
      }
    } else {
      if (wikiLink.value.startsWith("#")) {
        displayName = wikiLink.value.replace("#", "");
      } else {
        displayName = wikiLink.value;
      }
      wikiLink.data.hName = "a";
    }
    if (wikiLink.data.alias && !wikiLinkTransclusion) {
      displayName = wikiLink.data.alias;
    }
    var classNames = wikiLinkClassName;
    if (!exists) {
      classNames += " " + newClassName;
    }
    wikiLink.data.alias = displayName;
    if (wikiLinkTransclusion && transclusionFormat[1] === "pdf") {
      wikiLink.data.permalink = permalink + "#view=Fit";
    } else {
      wikiLink.data.permalink = permalink;
    }
    wikiLink.data.exists = exists;
    if (wikiLinkTransclusion) {
      if (!transclusionFormat[0]) {
        wikiLink.data.hProperties = {
          className: classNames + " no-support",
          style: "color:#fef08a;",
          src: hrefTemplate(permalink)
        };
      } else if (transclusionFormat[1] === "pdf") {
        wikiLink.data.hProperties = {
          className: classNames,
          width: "100%",
          style: "height:100vh;",
          type: "application/pdf",
          src: hrefTemplate(permalink) + "#view=Fit"
        };
      } else {
        wikiLink.data.hProperties = {
          className: classNames,
          src: hrefTemplate(permalink)
        };
      }
    } else {
      wikiLink.data.hProperties = {
        className: classNames,
        href: hrefTemplate(permalink)
      };
      wikiLink.data.hChildren = [{
        type: "text",
        value: displayName
      }];
    }
  }
  return {
    enter: {
      wikiLink: enterWikiLink
    },
    exit: {
      wikiLinkTarget: exitWikiLinkTarget,
      wikiLinkAlias: exitWikiLinkAlias,
      wikiLink: exitWikiLink
    }
  };
}

var codes = {
  horizontalTab: -2,
  virtualSpace: -1,
  nul: 0,
  eof: null,
  space: 32
};
function markdownLineEndingOrSpace(code) {
  return code < codes.nul || code === codes.space;
}
function markdownLineEnding(code) {
  return code < codes.horizontalTab;
}
function wikiLink() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var aliasDivider = opts.aliasDivider || ":";
  var aliasMarker = aliasDivider;
  var startMarker = "[[";
  var imageStartMarker = "![[";
  var endMarker = "]]";
  function tokenize(effects, ok, nok) {
    var data;
    var alias;
    var aliasCursor = 0;
    var startMarkerCursor = 0;
    var endMarkerCursor = 0;
    return start;
    function start(code) {
      if (code === startMarker.charCodeAt(startMarkerCursor)) {
        effects.enter("wikiLink");
        effects.enter("wikiLinkMarker");
        return consumeStart(code);
      } else if (code === imageStartMarker.charCodeAt(startMarkerCursor)) {
        effects.enter("wikiLink", {
          isType: "transclusions"
        });
        effects.enter("wikiLinkMarker", {
          isType: "transclusions"
        });
        return consumeStart(code);
      } else {
        return nok(code);
      }
    }
    function consumeStart(code) {
      if (startMarkerCursor === startMarker.length) {
        effects.exit("wikiLinkMarker");
        return consumeData(code);
      }
      if (code === startMarker.charCodeAt(startMarkerCursor) || code === imageStartMarker.charCodeAt(startMarkerCursor)) {
        effects.consume(code);
        if (code === 91) startMarkerCursor++;
        return consumeStart;
      } else {
        return nok(code);
      }
    }
    function consumeData(code) {
      if (markdownLineEnding(code) || code === codes.eof) {
        return nok(code);
      }
      effects.enter("wikiLinkData");
      effects.enter("wikiLinkTarget");
      return consumeTarget(code);
    }
    function consumeTarget(code) {
      if (code === aliasMarker.charCodeAt(aliasCursor)) {
        if (!data) return nok(code);
        effects.exit("wikiLinkTarget");
        effects.enter("wikiLinkAliasMarker");
        return consumeAliasMarker(code);
      }
      if (code === endMarker.charCodeAt(endMarkerCursor)) {
        if (!data) return nok(code);
        effects.exit("wikiLinkTarget");
        effects.exit("wikiLinkData");
        effects.enter("wikiLinkMarker");
        return consumeEnd(code);
      }
      if (markdownLineEnding(code) || code === codes.eof) {
        return nok(code);
      }
      if (!markdownLineEndingOrSpace(code)) {
        data = true;
      }
      effects.consume(code);
      return consumeTarget;
    }
    function consumeAliasMarker(code) {
      if (aliasCursor === aliasMarker.length) {
        effects.exit("wikiLinkAliasMarker");
        effects.enter("wikiLinkAlias");
        return consumeAlias(code);
      }
      if (code !== aliasMarker.charCodeAt(aliasCursor)) {
        return nok(code);
      }
      effects.consume(code);
      aliasCursor++;
      return consumeAliasMarker;
    }
    function consumeAlias(code) {
      if (code === endMarker.charCodeAt(endMarkerCursor)) {
        if (!alias) return nok(code);
        effects.exit("wikiLinkAlias");
        effects.exit("wikiLinkData");
        effects.enter("wikiLinkMarker");
        return consumeEnd(code);
      }
      if (markdownLineEnding(code) || code === codes.eof) {
        return nok(code);
      }
      if (!markdownLineEndingOrSpace(code)) {
        alias = true;
      }
      effects.consume(code);
      return consumeAlias;
    }
    function consumeEnd(code) {
      if (endMarkerCursor === endMarker.length) {
        effects.exit("wikiLinkMarker");
        effects.exit("wikiLink");
        return ok(code);
      }
      if (code !== endMarker.charCodeAt(endMarkerCursor)) {
        return nok(code);
      }
      effects.consume(code);
      endMarkerCursor++;
      return consumeEnd;
    }
  }
  var call = {
    tokenize: tokenize
  };
  return {
    text: {
      91: call,
      33: call
    } // 91: left square bracket, 33: exclamation mark
  };
}

var pipe = function pipe() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }
  return function (x) {
    return fns.reduce(function (v, f) {
      return f(v);
    }, x);
  };
};
var flattenArray = function flattenArray(input) {
  return input.reduce(function (acc, item) {
    return [].concat(_toConsumableArray(acc), _toConsumableArray(Array.isArray(item) ? item : [item]));
  }, []);
};
var map = function map(fn) {
  return function (input) {
    return input.map(fn);
  };
};
var walkDir = function walkDir(fullPath) {
  return fs.statSync(fullPath).isFile() ? fullPath : getAllFilesRecursively(fullPath);
};
var pathJoinPrefix = function pathJoinPrefix(prefix) {
  return function (extraPath) {
    return path.join(prefix, extraPath);
  };
};
var getAllFilesRecursively = function getAllFilesRecursively(folder) {
  return pipe(fs.readdirSync, map(pipe(pathJoinPrefix(folder), walkDir)), flattenArray)(folder);
};
function getFiles(type) {
  var prefixPaths = path.join(process.cwd(), type);
  var files = getAllFilesRecursively(prefixPaths);
  // Only want to return path and ignore root, replace is needed to work on Windows
  return files.map(function (file) {
    return file.slice(prefixPaths.length + 1).replace(/\\/g, "/");
  });
}

var warningIssued;
function wikiLinkPlugin() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    markdownFolder: ""
  };
  var data = this.data();
  function add(field, value) {
    if (data[field]) data[field].push(value);else data[field] = [value];
  }
  if (!warningIssued && (this.Parser && this.Parser.prototype && this.Parser.prototype.blockTokenizers || this.Compiler && this.Compiler.prototype && this.Compiler.prototype.visitors)) {
    warningIssued = true;
    console.warn("[remark-wiki-link] Warning: please upgrade to remark 13 to use this plugin");
  }
  opts = _objectSpread2(_objectSpread2({}, opts), {}, {
    aliasDivider: opts.aliasDivider ? opts.aliasDivider : "|",
    pageResolver: opts.pageResolver ? opts.pageResolver : function (name) {
      var image = wikiLinkTransclusionFormat(name)[1];
      var heading = "";
      if (!image && !name.startsWith("#") && name.match(/#/)) {
        var _name$split = name.split("#");
        var _name$split2 = _slicedToArray(_name$split, 2);
        heading = _name$split2[1];
        name = name.replace("#".concat(heading), "");
      }
      if (opts.permalinks || opts.markdownFolder) {
        var url = opts.permalinks.find(function (p) {
          return p === name || p.split("/").pop() === name && !opts.permalinks.includes(p.split("/").pop());
        });
        if (url) {
          if (heading) return ["".concat(url, "#").concat(heading).replace(/ /g, "-").toLowerCase()];
          return image ? [url] : [url.replace(/ /g, "-").toLowerCase()];
        }
      }
      return image ? [name] : [name.replace(/ /g, "-").toLowerCase()];
    },
    permalinks: opts.markdownFolder ? getFiles(opts.markdownFolder).map(function (file) {
      return file.replace(/\.mdx?$/, "");
    }) : opts.permalinks
  });
  add("micromarkExtensions", wikiLink(opts));
  add("fromMarkdownExtensions", fromMarkdown(opts));
  add("toMarkdownExtensions", toMarkdown(opts));
}

export { wikiLinkPlugin as default, wikiLinkPlugin };
