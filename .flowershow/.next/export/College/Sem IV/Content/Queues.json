{"pageProps":{"layout":"docs","data":[],"body":{"raw":"\n# What is a Queue\n\nA queue is a linear data structure that follows a First In First Out (FIFO) principle. This means that the first element added to the queue will be the first one to be removed.\n\nA queue has two main operations: enqueue and dequeue. Enqueue is the operation of adding an element to the end of the queue, and dequeue is the operation of removing the element from the front of the queue.\n\nQueues are often used to store data that needs to be processed in a specific order, or to store data that will be used by multiple consumers.\n\nAn example of a queue in real life is a line of people waiting to buy tickets at a ticket counter. The person at the front of the line is the first one to be served, and the person at the end of the line is the last one to be served.\n\nIn computer science, queues are often used to store data that needs to be transmitted over a network or to store tasks that need to be executed by a computer.\n\nThere are several variations of queues, including circular queues, priority queues, and double-ended queues (also known as deques).\n\n___\n\n# ADT of a Queue\n\nThe ADT (Abstract Data Type) of a queue is a set of operations that can be performed on a queue data structure. The essential  operations of a queue ADT are:\n\n-  `enqueue(element)`: adds an element to the end of the queue.\n-  `dequeue()`: removes and returns the element at the front of the queue.\n-  `peek()`: returns the element at the front of the queue without removing it.\n-  `is_empty()`: returns `true` if the queue is empty, `false` otherwise.\n-  `size()`: returns the number of elements in the queue.\n\nSome queue ADTs may also include additional operations, such as:\n\n-  `clear()`: removes all elements from the queue.\n-  `contains(element)`: returns `true` if the queue contains the given element, `false` otherwise.\n\nThe specific implementation of a queue ADT may vary depending on the language and the needs of the application. However, the basic operations described above are common to most queue ADTs.\n\n___\n\n# Implementation and Usage of a Queue in C++\n\n\n## Queue Array Implementation\n\n```C++\n\n#include <iostream>\nusing namespace std;\n\nconst int MAX_SIZE = 100;\n\nclass Queue {\n private:\n  int arr[MAX_SIZE];  // array to store the queue elements\n  int front;  // index of the front element\n  int rear;  // index of the rear element\n  int size;  // number of elements in the queue\n\n public:\n  Queue() { front = 0; rear = MAX_SIZE - 1; size = 0; }\n  bool enqueue(int x);  // add an element to the queue\n  int dequeue();  // remove and return the front element\n  int peek();  // get the front element\n  bool is_empty();  // check if the queue is empty\n  int get_size();  // get the number of elements in the queue\n};\n\n// Add an element to the queue\nbool Queue::enqueue(int x) {\n  // check for queue overflow\n  if (size >= MAX_SIZE) {\n    return false;\n  }\n  size++;\n  rear = (rear + 1) % MAX_SIZE;\n  arr[rear] = x;\n  return true;\n}\n\n// Remove and return the front element\nint Queue::dequeue() {\n  // check for queue underflow\n  if (is_empty()) {\n    return -1;\n  }\n  int x = arr[front];\n  front = (front + 1) % MAX_SIZE;\n  size--;\n  return x;\n}\n\n// Get the front element\nint Queue::peek() {\n  // check for queue underflow\n  if (is_empty()) {\n    return -1;\n  }\n  return arr[front];\n}\n\n// Check if the queue is empty\nbool Queue::is_empty() {\n  return (size == 0);\n}\n\n// Get the number of elements in the queue\nint Queue::get_size() {\n  return size;\n}\n\n \nint main() {\n  Queue queue;\n  queue.enqueue(1);\n  queue.enqueue(2);\n  queue.enqueue(3);\n  cout << queue.get_size() << endl;  // prints 3\n  cout << queue.peek() << endl;  // prints 1\n  cout << queue.dequeue() << endl;  // prints 1\n  cout << queue.is_empty() << endl;  // prints 0 (false)\n\n  return 0;\n}\n\n```\n\n___\n\n## Queue Linked List Implementation\n\n```C++\n\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n  int data;\n  Node* next;\n};\n\nclass Queue {\n private:\n  Node* front;  // pointer to the front of the queue\n  Node* rear;  // pointer to the rear of the queue\n  int size;  // number of elements in the queue\n\n public:\n  Queue() { front = NULL; rear = NULL; size = 0; }\n  bool enqueue(int x);  // add an element to the queue\n  int dequeue();  // remove and return the front element\n  int peek();  // get the front element\n  bool is_empty();  // check if the queue is empty\n  int get_size();  // get the number of elements in the queue\n};\n\n// Add an element to the queue\nbool Queue::enqueue(int x) {\n  // create a new node\n  Node* new_node = new Node();\n  new_node->data = x;\n  new_node->next = NULL;\n\n  // update the rear of the queue and the size\n  if (is_empty()) {\n    front = new_node;\n  } else {\n    rear->next = new_node;\n  }\n  rear = new_node;\n  size++;\n\n  return true;\n}\n\n// Remove and return the front element\nint Queue::dequeue() {\n  // check for queue underflow\n  if (is_empty()) {\n    return -1;\n  }\n\n  // get the data from the front node\n  int x = front->data;\n\n  // update the front of the queue and the size\n  Node* temp = front;\n  front = front->next;\n  delete temp;\n  size--;\n\n  // update the rear of the queue if the queue is now empty\n  if (is_empty()) {\n    rear = NULL;\n  }\n\n  return x;\n}\n\n// Get the front element\nint Queue::peek() {\n  // check for queue underflow\n  if (is_empty()) {\n    return -1;\n  }\n\n  return front->data;\n}\n\n// Check if the queue is empty\nbool Queue::is_empty() {\n  return (front == NULL);\n}\n\n// Get the number of elements in the queue\nint Queue::get_size() {\n  return size;\n}\n\nint main() {\n  Queue queue;\n  queue.enqueue(1);\n  queue.enqueue(2);\n  queue.enqueue(3);\n  cout << queue.get_size() << endl;  // prints 3\n  cout << queue.peek() << endl;  // prints 1\n  cout << queue.dequeue() << endl;  // prints 1\n  cout << queue.is_empty() << endl;  // prints 0 (false)\n\n  return 0;\n}\n\n```\n\n___\n\n","code":"var Component=(()=>{var h=Object.create;var c=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,N=Object.prototype.hasOwnProperty;var f=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),q=(a,e)=>{for(var l in e)c(a,l,{get:e[l],enumerable:!0})},d=(a,e,l,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of m(e))!N.call(a,s)&&s!==l&&c(a,s,{get:()=>e[s],enumerable:!(i=u(e,s))||i.enumerable});return a};var g=(a,e,l)=>(l=a!=null?h(p(a)):{},d(e||!a||!a.__esModule?c(l,\"default\",{value:a,enumerable:!0}):l,a)),b=a=>d(c({},\"__esModule\",{value:!0}),a);var o=f((y,r)=>{r.exports=_jsx_runtime});var v={};q(v,{default:()=>_});var n=g(o());function t(a){let e=Object.assign({h1:\"h1\",p:\"p\",hr:\"hr\",ul:\"ul\",li:\"li\",code:\"code\",h2:\"h2\",a:\"a\",svg:\"svg\",path:\"path\",pre:\"pre\",span:\"span\"},a.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h1,{id:\"what-is-a-queue\",children:\"What is a Queue\"}),`\n`,(0,n.jsx)(e.p,{children:\"A queue is a linear data structure that follows a First In First Out (FIFO) principle. This means that the first element added to the queue will be the first one to be removed.\"}),`\n`,(0,n.jsx)(e.p,{children:\"A queue has two main operations: enqueue and dequeue. Enqueue is the operation of adding an element to the end of the queue, and dequeue is the operation of removing the element from the front of the queue.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Queues are often used to store data that needs to be processed in a specific order, or to store data that will be used by multiple consumers.\"}),`\n`,(0,n.jsx)(e.p,{children:\"An example of a queue in real life is a line of people waiting to buy tickets at a ticket counter. The person at the front of the line is the first one to be served, and the person at the end of the line is the last one to be served.\"}),`\n`,(0,n.jsx)(e.p,{children:\"In computer science, queues are often used to store data that needs to be transmitted over a network or to store tasks that need to be executed by a computer.\"}),`\n`,(0,n.jsx)(e.p,{children:\"There are several variations of queues, including circular queues, priority queues, and double-ended queues (also known as deques).\"}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h1,{id:\"adt-of-a-queue\",children:\"ADT of a Queue\"}),`\n`,(0,n.jsx)(e.p,{children:\"The ADT (Abstract Data Type) of a queue is a set of operations that can be performed on a queue data structure. The essential  operations of a queue ADT are:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"enqueue(element)\"}),\": adds an element to the end of the queue.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"dequeue()\"}),\": removes and returns the element at the front of the queue.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"peek()\"}),\": returns the element at the front of the queue without removing it.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"is_empty()\"}),\": returns \",(0,n.jsx)(e.code,{children:\"true\"}),\" if the queue is empty, \",(0,n.jsx)(e.code,{children:\"false\"}),\" otherwise.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"size()\"}),\": returns the number of elements in the queue.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Some queue ADTs may also include additional operations, such as:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"clear()\"}),\": removes all elements from the queue.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"contains(element)\"}),\": returns \",(0,n.jsx)(e.code,{children:\"true\"}),\" if the queue contains the given element, \",(0,n.jsx)(e.code,{children:\"false\"}),\" otherwise.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"The specific implementation of a queue ADT may vary depending on the language and the needs of the application. However, the basic operations described above are common to most queue ADTs.\"}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h1,{id:\"implementation-and-usage-of-a-queue-in-c\",children:\"Implementation and Usage of a Queue in C++\"}),`\n`,(0,n.jsxs)(e.h2,{id:\"queue-array-implementation\",children:[(0,n.jsx)(e.a,{\"aria-hidden\":\"true\",tabIndex:\"-1\",href:\"#queue-array-implementation\",children:(0,n.jsx)(e.svg,{xmlns:\"http://www.w3.org/2000/svg\",fill:\"#ab2b65\",viewBox:\"0 0 20 20\",className:\"w-5 h-5\",children:(0,n.jsx)(e.path,{fillRule:\"evenodd\",clipRule:\"evenodd\",d:\"M9.493 2.853a.75.75 0 00-1.486-.205L7.545 6H4.198a.75.75 0 000 1.5h3.14l-.69 5H3.302a.75.75 0 000 1.5h3.14l-.435 3.148a.75.75 0 001.486.205L7.955 14h2.986l-.434 3.148a.75.75 0 001.486.205L12.456 14h3.346a.75.75 0 000-1.5h-3.14l.69-5h3.346a.75.75 0 000-1.5h-3.14l.435-3.147a.75.75 0 00-1.486-.205L12.045 6H9.059l.434-3.147zM8.852 7.5l-.69 5h2.986l.69-5H8.852z\"})})}),\"Queue Array Implementation\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"language-C++ code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`#include <iostream>\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`using namespace std;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`const int MAX_SIZE = 100;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`class Queue {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:` private:\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int arr[MAX_SIZE];  // array to store the queue elements\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int front;  // index of the front element\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int rear;  // index of the rear element\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int size;  // number of elements in the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:` public:\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  Queue() { front = 0; rear = MAX_SIZE - 1; size = 0; }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  bool enqueue(int x);  // add an element to the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int dequeue();  // remove and return the front element\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int peek();  // get the front element\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  bool is_empty();  // check if the queue is empty\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int get_size();  // get the number of elements in the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`};\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Add an element to the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`bool Queue::enqueue(int x) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  // check for queue overflow\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  if (size >= MAX_SIZE) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    return false;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  size++;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  rear = (rear + 1) % MAX_SIZE;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  arr[rear] = x;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return true;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Remove and return the front element\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`int Queue::dequeue() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  // check for queue underflow\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  if (is_empty()) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    return -1;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int x = arr[front];\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  front = (front + 1) % MAX_SIZE;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  size--;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return x;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Get the front element\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`int Queue::peek() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  // check for queue underflow\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  if (is_empty()) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    return -1;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return arr[front];\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Check if the queue is empty\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`bool Queue::is_empty() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return (size == 0);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Get the number of elements in the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`int Queue::get_size() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return size;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:` \n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`int main() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  Queue queue;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  queue.enqueue(1);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  queue.enqueue(2);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  queue.enqueue(3);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  cout << queue.get_size() << endl;  // prints 3\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  cout << queue.peek() << endl;  // prints 1\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  cout << queue.dequeue() << endl;  // prints 1\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  cout << queue.is_empty() << endl;  // prints 0 (false)\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return 0;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`})]})}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsxs)(e.h2,{id:\"queue-linked-list-implementation\",children:[(0,n.jsx)(e.a,{\"aria-hidden\":\"true\",tabIndex:\"-1\",href:\"#queue-linked-list-implementation\",children:(0,n.jsx)(e.svg,{xmlns:\"http://www.w3.org/2000/svg\",fill:\"#ab2b65\",viewBox:\"0 0 20 20\",className:\"w-5 h-5\",children:(0,n.jsx)(e.path,{fillRule:\"evenodd\",clipRule:\"evenodd\",d:\"M9.493 2.853a.75.75 0 00-1.486-.205L7.545 6H4.198a.75.75 0 000 1.5h3.14l-.69 5H3.302a.75.75 0 000 1.5h3.14l-.435 3.148a.75.75 0 001.486.205L7.955 14h2.986l-.434 3.148a.75.75 0 001.486.205L12.456 14h3.346a.75.75 0 000-1.5h-3.14l.69-5h3.346a.75.75 0 000-1.5h-3.14l.435-3.147a.75.75 0 00-1.486-.205L12.045 6H9.059l.434-3.147zM8.852 7.5l-.69 5h2.986l.69-5H8.852z\"})})}),\"Queue Linked List Implementation\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"language-C++ code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`#include <iostream>\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`using namespace std;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`struct Node {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int data;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  Node* next;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`};\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`class Queue {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:` private:\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  Node* front;  // pointer to the front of the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  Node* rear;  // pointer to the rear of the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int size;  // number of elements in the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:` public:\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  Queue() { front = NULL; rear = NULL; size = 0; }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  bool enqueue(int x);  // add an element to the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int dequeue();  // remove and return the front element\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int peek();  // get the front element\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  bool is_empty();  // check if the queue is empty\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int get_size();  // get the number of elements in the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`};\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Add an element to the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`bool Queue::enqueue(int x) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  // create a new node\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  Node* new_node = new Node();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  new_node->data = x;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  new_node->next = NULL;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  // update the rear of the queue and the size\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  if (is_empty()) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    front = new_node;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  } else {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    rear->next = new_node;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  rear = new_node;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  size++;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return true;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Remove and return the front element\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`int Queue::dequeue() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  // check for queue underflow\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  if (is_empty()) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    return -1;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  // get the data from the front node\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int x = front->data;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  // update the front of the queue and the size\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  Node* temp = front;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  front = front->next;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  delete temp;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  size--;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  // update the rear of the queue if the queue is now empty\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  if (is_empty()) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    rear = NULL;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return x;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Get the front element\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`int Queue::peek() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  // check for queue underflow\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  if (is_empty()) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    return -1;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return front->data;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Check if the queue is empty\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`bool Queue::is_empty() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return (front == NULL);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Get the number of elements in the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`int Queue::get_size() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return size;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`int main() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  Queue queue;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  queue.enqueue(1);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  queue.enqueue(2);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  queue.enqueue(3);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  cout << queue.get_size() << endl;  // prints 3\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  cout << queue.peek() << endl;  // prints 1\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  cout << queue.dequeue() << endl;  // prints 1\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  cout << queue.is_empty() << endl;  // prints 0 (false)\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return 0;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`})]})}),`\n`,(0,n.jsx)(e.hr,{})]})}function w(a={}){let{wrapper:e}=a.components||{};return e?(0,n.jsx)(e,Object.assign({},a,{children:(0,n.jsx)(t,a)})):t(a)}var _=w;return b(v);})();\n;return Component;"},"_id":"College/Sem IV/Content/Queues.md","_raw":{"sourceFilePath":"College/Sem IV/Content/Queues.md","sourceFileName":"Queues.md","sourceFileDir":"College/Sem IV/Content","contentType":"markdown","flattenedPath":"College/Sem IV/Content/Queues"},"type":"Page","url_path":"College/Sem IV/Content/Queues","slug":"Queues","authorsDetails":[],"globals":{}},"__N_SSG":true}