<!DOCTYPE html><html><head><title>Flowershow</title><meta property="og:title" content="Flowershow"/><link rel="icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text y=%22.9em%22 font-size=%2290%22&gt;ðŸ’&lt;/text&gt;&lt;/svg&gt;"/><meta charSet="utf-8"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta name="robots" content="index,follow"/><meta name="next-head-count" content="6"/><link rel="preload" href="/_next/static/css/0b37ae9fa3cb196d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0b37ae9fa3cb196d.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-08a53a89c57b2169.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-dc1c692d63c50e17.js" defer=""></script><script src="/_next/static/chunks/pages/_app-aa2f47433ae907d7.js" defer=""></script><script src="/_next/static/chunks/pages/%5B%5B...slug%5D%5D-c56bba745415c516.js" defer=""></script><script src="/_next/static/dx8-lOgzMavXNxsNaqq0-/_buildManifest.js" defer=""></script><script src="/_next/static/dx8-lOgzMavXNxsNaqq0-/_ssgManifest.js" defer=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&false)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}else{c.add('dark')}if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'dark'}catch(e){}}()</script><div class="min-h-screen bg-background dark:bg-background-dark"><header class="
        sticky top-0 z-50 flex items-center justify-between px-4 py-5 sm:px-6 lg:px-8 max-w-full
        dark:bg-slate-900
      "><div class="mr-2 sm:mr-4 flex lg:hidden"><button type="button" class="relative" aria-label="Open navigation"><svg aria-hidden="true" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" class="h-6 w-6 stroke-slate-500"><path d="M4 7h16M4 12h16M4 17h16"></path></svg></button><div style="position:fixed;top:1px;left:1px;width:1px;height:0;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0;display:none"></div></div><div class="flex flex-none items-center"><a aria-label="Home page" class="flex items-center font-extrabold text-xl sm:text-2xl text-slate-900 dark:text-white" href="/"><span>Flowershow</span></a><div class="hidden lg:flex ml-8 mr-6 sm:mr-8 md:mr-0"></div></div><div class="relative flex items-center basis-auto justify-end gap-6 xl:gap-8 md:shrink w-full"></div></header><div class="relative mx-auto"><main class="flex-auto"><article class="docs prose text-primary dark:text-primary-dark dark:prose-invert prose-headings:font-headings prose-a:break-words mx-auto p-6"><header><div class="mb-6"></div></header><section><h1 id="what-is-a-queue">What is a Queue</h1>
<p>A queue is a linear data structure that follows a First In First Out (FIFO) principle. This means that the first element added to the queue will be the first one to be removed.</p>
<p>A queue has two main operations: enqueue and dequeue. Enqueue is the operation of adding an element to the end of the queue, and dequeue is the operation of removing the element from the front of the queue.</p>
<p>Queues are often used to store data that needs to be processed in a specific order, or to store data that will be used by multiple consumers.</p>
<p>An example of a queue in real life is a line of people waiting to buy tickets at a ticket counter. The person at the front of the line is the first one to be served, and the person at the end of the line is the last one to be served.</p>
<p>In computer science, queues are often used to store data that needs to be transmitted over a network or to store tasks that need to be executed by a computer.</p>
<p>There are several variations of queues, including circular queues, priority queues, and double-ended queues (also known as deques).</p>
<hr/>
<h1 id="adt-of-a-queue">ADT of a Queue</h1>
<p>The ADT (Abstract Data Type) of a queue is a set of operations that can be performed on a queue data structure. The essential  operations of a queue ADT are:</p>
<ul>
<li><code>enqueue(element)</code>: adds an element to the end of the queue.</li>
<li><code>dequeue()</code>: removes and returns the element at the front of the queue.</li>
<li><code>peek()</code>: returns the element at the front of the queue without removing it.</li>
<li><code>is_empty()</code>: returns <code>true</code> if the queue is empty, <code>false</code> otherwise.</li>
<li><code>size()</code>: returns the number of elements in the queue.</li>
</ul>
<p>Some queue ADTs may also include additional operations, such as:</p>
<ul>
<li><code>clear()</code>: removes all elements from the queue.</li>
<li><code>contains(element)</code>: returns <code>true</code> if the queue contains the given element, <code>false</code> otherwise.</li>
</ul>
<p>The specific implementation of a queue ADT may vary depending on the language and the needs of the application. However, the basic operations described above are common to most queue ADTs.</p>
<hr/>
<h1 id="implementation-and-usage-of-a-queue-in-c">Implementation and Usage of a Queue in C++</h1>
<h2 id="queue-array-implementation"><a href="#queue-array-implementation" aria-hidden="true" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" fill="#ab2b65" viewBox="0 0 20 20" class="w-5 h-5"><path fill-rule="evenodd" clip-rule="evenodd" d="M9.493 2.853a.75.75 0 00-1.486-.205L7.545 6H4.198a.75.75 0 000 1.5h3.14l-.69 5H3.302a.75.75 0 000 1.5h3.14l-.435 3.148a.75.75 0 001.486.205L7.955 14h2.986l-.434 3.148a.75.75 0 001.486.205L12.456 14h3.346a.75.75 0 000-1.5h-3.14l.69-5h3.346a.75.75 0 000-1.5h-3.14l.435-3.147a.75.75 0 00-1.486-.205L12.045 6H9.059l.434-3.147zM8.852 7.5l-.69 5h2.986l.69-5H8.852z"></path></svg></a>Queue Array Implementation</h2>
<div class="relative"><pre><code class="language-C++ code-highlight"><span class="code-line">
</span><span class="code-line">#include &lt;iostream&gt;
</span><span class="code-line">using namespace std;
</span><span class="code-line">
</span><span class="code-line">const int MAX_SIZE = 100;
</span><span class="code-line">
</span><span class="code-line">class Queue {
</span><span class="code-line"> private:
</span><span class="code-line">  int arr[MAX_SIZE];  // array to store the queue elements
</span><span class="code-line">  int front;  // index of the front element
</span><span class="code-line">  int rear;  // index of the rear element
</span><span class="code-line">  int size;  // number of elements in the queue
</span><span class="code-line">
</span><span class="code-line"> public:
</span><span class="code-line">  Queue() { front = 0; rear = MAX_SIZE - 1; size = 0; }
</span><span class="code-line">  bool enqueue(int x);  // add an element to the queue
</span><span class="code-line">  int dequeue();  // remove and return the front element
</span><span class="code-line">  int peek();  // get the front element
</span><span class="code-line">  bool is_empty();  // check if the queue is empty
</span><span class="code-line">  int get_size();  // get the number of elements in the queue
</span><span class="code-line">};
</span><span class="code-line">
</span><span class="code-line">// Add an element to the queue
</span><span class="code-line">bool Queue::enqueue(int x) {
</span><span class="code-line">  // check for queue overflow
</span><span class="code-line">  if (size &gt;= MAX_SIZE) {
</span><span class="code-line">    return false;
</span><span class="code-line">  }
</span><span class="code-line">  size++;
</span><span class="code-line">  rear = (rear + 1) % MAX_SIZE;
</span><span class="code-line">  arr[rear] = x;
</span><span class="code-line">  return true;
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line">// Remove and return the front element
</span><span class="code-line">int Queue::dequeue() {
</span><span class="code-line">  // check for queue underflow
</span><span class="code-line">  if (is_empty()) {
</span><span class="code-line">    return -1;
</span><span class="code-line">  }
</span><span class="code-line">  int x = arr[front];
</span><span class="code-line">  front = (front + 1) % MAX_SIZE;
</span><span class="code-line">  size--;
</span><span class="code-line">  return x;
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line">// Get the front element
</span><span class="code-line">int Queue::peek() {
</span><span class="code-line">  // check for queue underflow
</span><span class="code-line">  if (is_empty()) {
</span><span class="code-line">    return -1;
</span><span class="code-line">  }
</span><span class="code-line">  return arr[front];
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line">// Check if the queue is empty
</span><span class="code-line">bool Queue::is_empty() {
</span><span class="code-line">  return (size == 0);
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line">// Get the number of elements in the queue
</span><span class="code-line">int Queue::get_size() {
</span><span class="code-line">  return size;
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line"> 
</span><span class="code-line">int main() {
</span><span class="code-line">  Queue queue;
</span><span class="code-line">  queue.enqueue(1);
</span><span class="code-line">  queue.enqueue(2);
</span><span class="code-line">  queue.enqueue(3);
</span><span class="code-line">  cout &lt;&lt; queue.get_size() &lt;&lt; endl;  // prints 3
</span><span class="code-line">  cout &lt;&lt; queue.peek() &lt;&lt; endl;  // prints 1
</span><span class="code-line">  cout &lt;&lt; queue.dequeue() &lt;&lt; endl;  // prints 1
</span><span class="code-line">  cout &lt;&lt; queue.is_empty() &lt;&lt; endl;  // prints 0 (false)
</span><span class="code-line">
</span><span class="code-line">  return 0;
</span><span class="code-line">}
</span><span class="code-line">
</span></code></pre></div>
<hr/>
<h2 id="queue-linked-list-implementation"><a href="#queue-linked-list-implementation" aria-hidden="true" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" fill="#ab2b65" viewBox="0 0 20 20" class="w-5 h-5"><path fill-rule="evenodd" clip-rule="evenodd" d="M9.493 2.853a.75.75 0 00-1.486-.205L7.545 6H4.198a.75.75 0 000 1.5h3.14l-.69 5H3.302a.75.75 0 000 1.5h3.14l-.435 3.148a.75.75 0 001.486.205L7.955 14h2.986l-.434 3.148a.75.75 0 001.486.205L12.456 14h3.346a.75.75 0 000-1.5h-3.14l.69-5h3.346a.75.75 0 000-1.5h-3.14l.435-3.147a.75.75 0 00-1.486-.205L12.045 6H9.059l.434-3.147zM8.852 7.5l-.69 5h2.986l.69-5H8.852z"></path></svg></a>Queue Linked List Implementation</h2>
<div class="relative"><pre><code class="language-C++ code-highlight"><span class="code-line">
</span><span class="code-line">#include &lt;iostream&gt;
</span><span class="code-line">using namespace std;
</span><span class="code-line">
</span><span class="code-line">struct Node {
</span><span class="code-line">  int data;
</span><span class="code-line">  Node* next;
</span><span class="code-line">};
</span><span class="code-line">
</span><span class="code-line">class Queue {
</span><span class="code-line"> private:
</span><span class="code-line">  Node* front;  // pointer to the front of the queue
</span><span class="code-line">  Node* rear;  // pointer to the rear of the queue
</span><span class="code-line">  int size;  // number of elements in the queue
</span><span class="code-line">
</span><span class="code-line"> public:
</span><span class="code-line">  Queue() { front = NULL; rear = NULL; size = 0; }
</span><span class="code-line">  bool enqueue(int x);  // add an element to the queue
</span><span class="code-line">  int dequeue();  // remove and return the front element
</span><span class="code-line">  int peek();  // get the front element
</span><span class="code-line">  bool is_empty();  // check if the queue is empty
</span><span class="code-line">  int get_size();  // get the number of elements in the queue
</span><span class="code-line">};
</span><span class="code-line">
</span><span class="code-line">// Add an element to the queue
</span><span class="code-line">bool Queue::enqueue(int x) {
</span><span class="code-line">  // create a new node
</span><span class="code-line">  Node* new_node = new Node();
</span><span class="code-line">  new_node-&gt;data = x;
</span><span class="code-line">  new_node-&gt;next = NULL;
</span><span class="code-line">
</span><span class="code-line">  // update the rear of the queue and the size
</span><span class="code-line">  if (is_empty()) {
</span><span class="code-line">    front = new_node;
</span><span class="code-line">  } else {
</span><span class="code-line">    rear-&gt;next = new_node;
</span><span class="code-line">  }
</span><span class="code-line">  rear = new_node;
</span><span class="code-line">  size++;
</span><span class="code-line">
</span><span class="code-line">  return true;
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line">// Remove and return the front element
</span><span class="code-line">int Queue::dequeue() {
</span><span class="code-line">  // check for queue underflow
</span><span class="code-line">  if (is_empty()) {
</span><span class="code-line">    return -1;
</span><span class="code-line">  }
</span><span class="code-line">
</span><span class="code-line">  // get the data from the front node
</span><span class="code-line">  int x = front-&gt;data;
</span><span class="code-line">
</span><span class="code-line">  // update the front of the queue and the size
</span><span class="code-line">  Node* temp = front;
</span><span class="code-line">  front = front-&gt;next;
</span><span class="code-line">  delete temp;
</span><span class="code-line">  size--;
</span><span class="code-line">
</span><span class="code-line">  // update the rear of the queue if the queue is now empty
</span><span class="code-line">  if (is_empty()) {
</span><span class="code-line">    rear = NULL;
</span><span class="code-line">  }
</span><span class="code-line">
</span><span class="code-line">  return x;
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line">// Get the front element
</span><span class="code-line">int Queue::peek() {
</span><span class="code-line">  // check for queue underflow
</span><span class="code-line">  if (is_empty()) {
</span><span class="code-line">    return -1;
</span><span class="code-line">  }
</span><span class="code-line">
</span><span class="code-line">  return front-&gt;data;
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line">// Check if the queue is empty
</span><span class="code-line">bool Queue::is_empty() {
</span><span class="code-line">  return (front == NULL);
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line">// Get the number of elements in the queue
</span><span class="code-line">int Queue::get_size() {
</span><span class="code-line">  return size;
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line">int main() {
</span><span class="code-line">  Queue queue;
</span><span class="code-line">  queue.enqueue(1);
</span><span class="code-line">  queue.enqueue(2);
</span><span class="code-line">  queue.enqueue(3);
</span><span class="code-line">  cout &lt;&lt; queue.get_size() &lt;&lt; endl;  // prints 3
</span><span class="code-line">  cout &lt;&lt; queue.peek() &lt;&lt; endl;  // prints 1
</span><span class="code-line">  cout &lt;&lt; queue.dequeue() &lt;&lt; endl;  // prints 1
</span><span class="code-line">  cout &lt;&lt; queue.is_empty() &lt;&lt; endl;  // prints 0 (false)
</span><span class="code-line">
</span><span class="code-line">  return 0;
</span><span class="code-line">}
</span><span class="code-line">
</span></code></pre></div>
<hr/></section></article>;</main></div><footer class="bg-background dark:bg-background-dark prose dark:prose-invert max-w-none flex flex-col items-center justify-center w-full h-auto pt-10 pb-20"><div class="flex w-full flex-wrap justify-center"></div><p class="flex items-center justify-center">Created by<a href="" target="_blank" rel="noopener noreferrer" class="flex items-center no-underline"></a></p><p class="flex items-center justify-center">Made with<a href="https://flowershow.app/" target="_blank" rel="noopener noreferrer" class="flex items-center no-underline"><img src="https://flowershow.app/assets/images/logo.svg" alt="Flowershow" class="my-0 h-6 block"/>Flowershow</a></p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"layout":"docs","data":[],"body":{"raw":"\n# What is a Queue\n\nA queue is a linear data structure that follows a First In First Out (FIFO) principle. This means that the first element added to the queue will be the first one to be removed.\n\nA queue has two main operations: enqueue and dequeue. Enqueue is the operation of adding an element to the end of the queue, and dequeue is the operation of removing the element from the front of the queue.\n\nQueues are often used to store data that needs to be processed in a specific order, or to store data that will be used by multiple consumers.\n\nAn example of a queue in real life is a line of people waiting to buy tickets at a ticket counter. The person at the front of the line is the first one to be served, and the person at the end of the line is the last one to be served.\n\nIn computer science, queues are often used to store data that needs to be transmitted over a network or to store tasks that need to be executed by a computer.\n\nThere are several variations of queues, including circular queues, priority queues, and double-ended queues (also known as deques).\n\n___\n\n# ADT of a Queue\n\nThe ADT (Abstract Data Type) of a queue is a set of operations that can be performed on a queue data structure. The essential  operations of a queue ADT are:\n\n-  `enqueue(element)`: adds an element to the end of the queue.\n-  `dequeue()`: removes and returns the element at the front of the queue.\n-  `peek()`: returns the element at the front of the queue without removing it.\n-  `is_empty()`: returns `true` if the queue is empty, `false` otherwise.\n-  `size()`: returns the number of elements in the queue.\n\nSome queue ADTs may also include additional operations, such as:\n\n-  `clear()`: removes all elements from the queue.\n-  `contains(element)`: returns `true` if the queue contains the given element, `false` otherwise.\n\nThe specific implementation of a queue ADT may vary depending on the language and the needs of the application. However, the basic operations described above are common to most queue ADTs.\n\n___\n\n# Implementation and Usage of a Queue in C++\n\n\n## Queue Array Implementation\n\n```C++\n\n#include \u003ciostream\u003e\nusing namespace std;\n\nconst int MAX_SIZE = 100;\n\nclass Queue {\n private:\n  int arr[MAX_SIZE];  // array to store the queue elements\n  int front;  // index of the front element\n  int rear;  // index of the rear element\n  int size;  // number of elements in the queue\n\n public:\n  Queue() { front = 0; rear = MAX_SIZE - 1; size = 0; }\n  bool enqueue(int x);  // add an element to the queue\n  int dequeue();  // remove and return the front element\n  int peek();  // get the front element\n  bool is_empty();  // check if the queue is empty\n  int get_size();  // get the number of elements in the queue\n};\n\n// Add an element to the queue\nbool Queue::enqueue(int x) {\n  // check for queue overflow\n  if (size \u003e= MAX_SIZE) {\n    return false;\n  }\n  size++;\n  rear = (rear + 1) % MAX_SIZE;\n  arr[rear] = x;\n  return true;\n}\n\n// Remove and return the front element\nint Queue::dequeue() {\n  // check for queue underflow\n  if (is_empty()) {\n    return -1;\n  }\n  int x = arr[front];\n  front = (front + 1) % MAX_SIZE;\n  size--;\n  return x;\n}\n\n// Get the front element\nint Queue::peek() {\n  // check for queue underflow\n  if (is_empty()) {\n    return -1;\n  }\n  return arr[front];\n}\n\n// Check if the queue is empty\nbool Queue::is_empty() {\n  return (size == 0);\n}\n\n// Get the number of elements in the queue\nint Queue::get_size() {\n  return size;\n}\n\n \nint main() {\n  Queue queue;\n  queue.enqueue(1);\n  queue.enqueue(2);\n  queue.enqueue(3);\n  cout \u003c\u003c queue.get_size() \u003c\u003c endl;  // prints 3\n  cout \u003c\u003c queue.peek() \u003c\u003c endl;  // prints 1\n  cout \u003c\u003c queue.dequeue() \u003c\u003c endl;  // prints 1\n  cout \u003c\u003c queue.is_empty() \u003c\u003c endl;  // prints 0 (false)\n\n  return 0;\n}\n\n```\n\n___\n\n## Queue Linked List Implementation\n\n```C++\n\n#include \u003ciostream\u003e\nusing namespace std;\n\nstruct Node {\n  int data;\n  Node* next;\n};\n\nclass Queue {\n private:\n  Node* front;  // pointer to the front of the queue\n  Node* rear;  // pointer to the rear of the queue\n  int size;  // number of elements in the queue\n\n public:\n  Queue() { front = NULL; rear = NULL; size = 0; }\n  bool enqueue(int x);  // add an element to the queue\n  int dequeue();  // remove and return the front element\n  int peek();  // get the front element\n  bool is_empty();  // check if the queue is empty\n  int get_size();  // get the number of elements in the queue\n};\n\n// Add an element to the queue\nbool Queue::enqueue(int x) {\n  // create a new node\n  Node* new_node = new Node();\n  new_node-\u003edata = x;\n  new_node-\u003enext = NULL;\n\n  // update the rear of the queue and the size\n  if (is_empty()) {\n    front = new_node;\n  } else {\n    rear-\u003enext = new_node;\n  }\n  rear = new_node;\n  size++;\n\n  return true;\n}\n\n// Remove and return the front element\nint Queue::dequeue() {\n  // check for queue underflow\n  if (is_empty()) {\n    return -1;\n  }\n\n  // get the data from the front node\n  int x = front-\u003edata;\n\n  // update the front of the queue and the size\n  Node* temp = front;\n  front = front-\u003enext;\n  delete temp;\n  size--;\n\n  // update the rear of the queue if the queue is now empty\n  if (is_empty()) {\n    rear = NULL;\n  }\n\n  return x;\n}\n\n// Get the front element\nint Queue::peek() {\n  // check for queue underflow\n  if (is_empty()) {\n    return -1;\n  }\n\n  return front-\u003edata;\n}\n\n// Check if the queue is empty\nbool Queue::is_empty() {\n  return (front == NULL);\n}\n\n// Get the number of elements in the queue\nint Queue::get_size() {\n  return size;\n}\n\nint main() {\n  Queue queue;\n  queue.enqueue(1);\n  queue.enqueue(2);\n  queue.enqueue(3);\n  cout \u003c\u003c queue.get_size() \u003c\u003c endl;  // prints 3\n  cout \u003c\u003c queue.peek() \u003c\u003c endl;  // prints 1\n  cout \u003c\u003c queue.dequeue() \u003c\u003c endl;  // prints 1\n  cout \u003c\u003c queue.is_empty() \u003c\u003c endl;  // prints 0 (false)\n\n  return 0;\n}\n\n```\n\n___\n\n","code":"var Component=(()=\u003e{var h=Object.create;var c=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,N=Object.prototype.hasOwnProperty;var f=(a,e)=\u003e()=\u003e(e||a((e={exports:{}}).exports,e),e.exports),q=(a,e)=\u003e{for(var l in e)c(a,l,{get:e[l],enumerable:!0})},d=(a,e,l,i)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let s of m(e))!N.call(a,s)\u0026\u0026s!==l\u0026\u0026c(a,s,{get:()=\u003ee[s],enumerable:!(i=u(e,s))||i.enumerable});return a};var g=(a,e,l)=\u003e(l=a!=null?h(p(a)):{},d(e||!a||!a.__esModule?c(l,\"default\",{value:a,enumerable:!0}):l,a)),b=a=\u003ed(c({},\"__esModule\",{value:!0}),a);var o=f((y,r)=\u003e{r.exports=_jsx_runtime});var v={};q(v,{default:()=\u003e_});var n=g(o());function t(a){let e=Object.assign({h1:\"h1\",p:\"p\",hr:\"hr\",ul:\"ul\",li:\"li\",code:\"code\",h2:\"h2\",a:\"a\",svg:\"svg\",path:\"path\",pre:\"pre\",span:\"span\"},a.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h1,{id:\"what-is-a-queue\",children:\"What is a Queue\"}),`\n`,(0,n.jsx)(e.p,{children:\"A queue is a linear data structure that follows a First In First Out (FIFO) principle. This means that the first element added to the queue will be the first one to be removed.\"}),`\n`,(0,n.jsx)(e.p,{children:\"A queue has two main operations: enqueue and dequeue. Enqueue is the operation of adding an element to the end of the queue, and dequeue is the operation of removing the element from the front of the queue.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Queues are often used to store data that needs to be processed in a specific order, or to store data that will be used by multiple consumers.\"}),`\n`,(0,n.jsx)(e.p,{children:\"An example of a queue in real life is a line of people waiting to buy tickets at a ticket counter. The person at the front of the line is the first one to be served, and the person at the end of the line is the last one to be served.\"}),`\n`,(0,n.jsx)(e.p,{children:\"In computer science, queues are often used to store data that needs to be transmitted over a network or to store tasks that need to be executed by a computer.\"}),`\n`,(0,n.jsx)(e.p,{children:\"There are several variations of queues, including circular queues, priority queues, and double-ended queues (also known as deques).\"}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h1,{id:\"adt-of-a-queue\",children:\"ADT of a Queue\"}),`\n`,(0,n.jsx)(e.p,{children:\"The ADT (Abstract Data Type) of a queue is a set of operations that can be performed on a queue data structure. The essential  operations of a queue ADT are:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"enqueue(element)\"}),\": adds an element to the end of the queue.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"dequeue()\"}),\": removes and returns the element at the front of the queue.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"peek()\"}),\": returns the element at the front of the queue without removing it.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"is_empty()\"}),\": returns \",(0,n.jsx)(e.code,{children:\"true\"}),\" if the queue is empty, \",(0,n.jsx)(e.code,{children:\"false\"}),\" otherwise.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"size()\"}),\": returns the number of elements in the queue.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Some queue ADTs may also include additional operations, such as:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"clear()\"}),\": removes all elements from the queue.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"contains(element)\"}),\": returns \",(0,n.jsx)(e.code,{children:\"true\"}),\" if the queue contains the given element, \",(0,n.jsx)(e.code,{children:\"false\"}),\" otherwise.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"The specific implementation of a queue ADT may vary depending on the language and the needs of the application. However, the basic operations described above are common to most queue ADTs.\"}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h1,{id:\"implementation-and-usage-of-a-queue-in-c\",children:\"Implementation and Usage of a Queue in C++\"}),`\n`,(0,n.jsxs)(e.h2,{id:\"queue-array-implementation\",children:[(0,n.jsx)(e.a,{\"aria-hidden\":\"true\",tabIndex:\"-1\",href:\"#queue-array-implementation\",children:(0,n.jsx)(e.svg,{xmlns:\"http://www.w3.org/2000/svg\",fill:\"#ab2b65\",viewBox:\"0 0 20 20\",className:\"w-5 h-5\",children:(0,n.jsx)(e.path,{fillRule:\"evenodd\",clipRule:\"evenodd\",d:\"M9.493 2.853a.75.75 0 00-1.486-.205L7.545 6H4.198a.75.75 0 000 1.5h3.14l-.69 5H3.302a.75.75 0 000 1.5h3.14l-.435 3.148a.75.75 0 001.486.205L7.955 14h2.986l-.434 3.148a.75.75 0 001.486.205L12.456 14h3.346a.75.75 0 000-1.5h-3.14l.69-5h3.346a.75.75 0 000-1.5h-3.14l.435-3.147a.75.75 0 00-1.486-.205L12.045 6H9.059l.434-3.147zM8.852 7.5l-.69 5h2.986l.69-5H8.852z\"})})}),\"Queue Array Implementation\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"language-C++ code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`#include \u003ciostream\u003e\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`using namespace std;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`const int MAX_SIZE = 100;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`class Queue {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:` private:\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int arr[MAX_SIZE];  // array to store the queue elements\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int front;  // index of the front element\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int rear;  // index of the rear element\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int size;  // number of elements in the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:` public:\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  Queue() { front = 0; rear = MAX_SIZE - 1; size = 0; }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  bool enqueue(int x);  // add an element to the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int dequeue();  // remove and return the front element\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int peek();  // get the front element\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  bool is_empty();  // check if the queue is empty\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int get_size();  // get the number of elements in the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`};\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Add an element to the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`bool Queue::enqueue(int x) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  // check for queue overflow\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  if (size \u003e= MAX_SIZE) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    return false;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  size++;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  rear = (rear + 1) % MAX_SIZE;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  arr[rear] = x;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return true;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Remove and return the front element\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`int Queue::dequeue() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  // check for queue underflow\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  if (is_empty()) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    return -1;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int x = arr[front];\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  front = (front + 1) % MAX_SIZE;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  size--;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return x;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Get the front element\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`int Queue::peek() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  // check for queue underflow\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  if (is_empty()) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    return -1;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return arr[front];\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Check if the queue is empty\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`bool Queue::is_empty() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return (size == 0);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Get the number of elements in the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`int Queue::get_size() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return size;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:` \n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`int main() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  Queue queue;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  queue.enqueue(1);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  queue.enqueue(2);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  queue.enqueue(3);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  cout \u003c\u003c queue.get_size() \u003c\u003c endl;  // prints 3\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  cout \u003c\u003c queue.peek() \u003c\u003c endl;  // prints 1\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  cout \u003c\u003c queue.dequeue() \u003c\u003c endl;  // prints 1\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  cout \u003c\u003c queue.is_empty() \u003c\u003c endl;  // prints 0 (false)\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return 0;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`})]})}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsxs)(e.h2,{id:\"queue-linked-list-implementation\",children:[(0,n.jsx)(e.a,{\"aria-hidden\":\"true\",tabIndex:\"-1\",href:\"#queue-linked-list-implementation\",children:(0,n.jsx)(e.svg,{xmlns:\"http://www.w3.org/2000/svg\",fill:\"#ab2b65\",viewBox:\"0 0 20 20\",className:\"w-5 h-5\",children:(0,n.jsx)(e.path,{fillRule:\"evenodd\",clipRule:\"evenodd\",d:\"M9.493 2.853a.75.75 0 00-1.486-.205L7.545 6H4.198a.75.75 0 000 1.5h3.14l-.69 5H3.302a.75.75 0 000 1.5h3.14l-.435 3.148a.75.75 0 001.486.205L7.955 14h2.986l-.434 3.148a.75.75 0 001.486.205L12.456 14h3.346a.75.75 0 000-1.5h-3.14l.69-5h3.346a.75.75 0 000-1.5h-3.14l.435-3.147a.75.75 0 00-1.486-.205L12.045 6H9.059l.434-3.147zM8.852 7.5l-.69 5h2.986l.69-5H8.852z\"})})}),\"Queue Linked List Implementation\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"language-C++ code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`#include \u003ciostream\u003e\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`using namespace std;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`struct Node {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int data;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  Node* next;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`};\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`class Queue {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:` private:\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  Node* front;  // pointer to the front of the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  Node* rear;  // pointer to the rear of the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int size;  // number of elements in the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:` public:\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  Queue() { front = NULL; rear = NULL; size = 0; }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  bool enqueue(int x);  // add an element to the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int dequeue();  // remove and return the front element\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int peek();  // get the front element\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  bool is_empty();  // check if the queue is empty\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int get_size();  // get the number of elements in the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`};\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Add an element to the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`bool Queue::enqueue(int x) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  // create a new node\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  Node* new_node = new Node();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  new_node-\u003edata = x;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  new_node-\u003enext = NULL;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  // update the rear of the queue and the size\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  if (is_empty()) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    front = new_node;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  } else {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    rear-\u003enext = new_node;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  rear = new_node;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  size++;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return true;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Remove and return the front element\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`int Queue::dequeue() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  // check for queue underflow\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  if (is_empty()) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    return -1;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  // get the data from the front node\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  int x = front-\u003edata;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  // update the front of the queue and the size\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  Node* temp = front;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  front = front-\u003enext;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  delete temp;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  size--;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  // update the rear of the queue if the queue is now empty\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  if (is_empty()) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    rear = NULL;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return x;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Get the front element\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`int Queue::peek() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  // check for queue underflow\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  if (is_empty()) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    return -1;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return front-\u003edata;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Check if the queue is empty\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`bool Queue::is_empty() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return (front == NULL);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Get the number of elements in the queue\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`int Queue::get_size() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return size;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`int main() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  Queue queue;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  queue.enqueue(1);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  queue.enqueue(2);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  queue.enqueue(3);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  cout \u003c\u003c queue.get_size() \u003c\u003c endl;  // prints 3\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  cout \u003c\u003c queue.peek() \u003c\u003c endl;  // prints 1\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  cout \u003c\u003c queue.dequeue() \u003c\u003c endl;  // prints 1\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  cout \u003c\u003c queue.is_empty() \u003c\u003c endl;  // prints 0 (false)\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  return 0;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`})]})}),`\n`,(0,n.jsx)(e.hr,{})]})}function w(a={}){let{wrapper:e}=a.components||{};return e?(0,n.jsx)(e,Object.assign({},a,{children:(0,n.jsx)(t,a)})):t(a)}var _=w;return b(v);})();\n;return Component;"},"_id":"College/Sem IV/Content/Queues.md","_raw":{"sourceFilePath":"College/Sem IV/Content/Queues.md","sourceFileName":"Queues.md","sourceFileDir":"College/Sem IV/Content","contentType":"markdown","flattenedPath":"College/Sem IV/Content/Queues"},"type":"Page","url_path":"College/Sem IV/Content/Queues","slug":"Queues","authorsDetails":[],"globals":{}},"__N_SSG":true},"page":"/[[...slug]]","query":{"slug":["College","Sem IV","Content","Queues"]},"buildId":"dx8-lOgzMavXNxsNaqq0-","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>