<!DOCTYPE html><html><head><title>Flowershow</title><meta property="og:title" content="Flowershow"/><link rel="icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text y=%22.9em%22 font-size=%2290%22&gt;ðŸ’&lt;/text&gt;&lt;/svg&gt;"/><meta charSet="utf-8"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta name="robots" content="index,follow"/><meta name="next-head-count" content="6"/><link rel="preload" href="/_next/static/css/0b37ae9fa3cb196d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0b37ae9fa3cb196d.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-08a53a89c57b2169.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-dc1c692d63c50e17.js" defer=""></script><script src="/_next/static/chunks/pages/_app-aa2f47433ae907d7.js" defer=""></script><script src="/_next/static/chunks/pages/%5B%5B...slug%5D%5D-c56bba745415c516.js" defer=""></script><script src="/_next/static/dx8-lOgzMavXNxsNaqq0-/_buildManifest.js" defer=""></script><script src="/_next/static/dx8-lOgzMavXNxsNaqq0-/_ssgManifest.js" defer=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&false)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}else{c.add('dark')}if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'dark'}catch(e){}}()</script><div class="min-h-screen bg-background dark:bg-background-dark"><header class="
        sticky top-0 z-50 flex items-center justify-between px-4 py-5 sm:px-6 lg:px-8 max-w-full
        dark:bg-slate-900
      "><div class="mr-2 sm:mr-4 flex lg:hidden"><button type="button" class="relative" aria-label="Open navigation"><svg aria-hidden="true" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" class="h-6 w-6 stroke-slate-500"><path d="M4 7h16M4 12h16M4 17h16"></path></svg></button><div style="position:fixed;top:1px;left:1px;width:1px;height:0;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0;display:none"></div></div><div class="flex flex-none items-center"><a aria-label="Home page" class="flex items-center font-extrabold text-xl sm:text-2xl text-slate-900 dark:text-white" href="/"><span>Flowershow</span></a><div class="hidden lg:flex ml-8 mr-6 sm:mr-8 md:mr-0"></div></div><div class="relative flex items-center basis-auto justify-end gap-6 xl:gap-8 md:shrink w-full"></div></header><div class="relative mx-auto"><main class="flex-auto"><article class="docs prose text-primary dark:text-primary-dark dark:prose-invert prose-headings:font-headings prose-a:break-words mx-auto p-6"><header><div class="mb-6"></div></header><section><h1 id="what-is-a-linked-list">What is a Linked List</h1>
<ul>
<li>A linked list is a linear data structure in which elements are stored in nodes, and each node has a reference, or a link, to the next node in the list.</li>
<li>The first node in a linked list is called the head, and the last node is called the tail.</li>
<li>Linked lists can be used to implement many different data structures, such as stacks, queues, and symbol tables.</li>
<li>One of the main advantages of linked lists is that they allow for efficient insertion and deletion of elements, since elements can be added or removed by updating the links between the nodes.</li>
<li>However, linked lists are not as efficient as arrays for accessing elements by their index, since elements in a linked list must be accessed sequentially starting from the head of the list.</li>
<li>There are two main types of linked lists: singly linked lists and doubly linked lists. In a singly linked list, each node has a link to the next node in the list, but not to the previous node.</li>
<li>In a doubly linked list, each node has a link to both the next node and the previous node.</li>
<li>There are also several variations of linked lists, such as circular linked lists and threaded linked lists. In a circular linked list, the tail node of the list has a link to the head node, forming a loop.</li>
<li>In a threaded linked list, nodes may have a link to the next node in the list, as well as a link to the successor in a particular order (such as in-order or pre-order traversal of a tree).</li>
<li>Linked lists have several applications, including being used as the underlying data structure for implementing dynamic arrays, which can grow and shrink as needed.</li>
<li>They are also commonly used to implement graphs, which consist of nodes and edges connecting them.</li>
</ul>
<p>Overall, linked lists are a flexible and efficient data structure that is useful in a wide range of applications.</p>
<hr/>
<h1 id="adt-of-a-linked-list">ADT of a Linked List</h1>
<p>The abstract data type (ADT) of a linked list is a linear collection of data elements, in which each element (also called a node) stores a reference to the next element in the list. A linked list ADT can support the following operations:</p>
<ol>
<li><code>Insert()</code>: Add a new element to the list.</li>
<li><code>Delete()</code>: Remove an element from the list.</li>
<li><code>Find()</code>: Search for an element in the list and return its position.</li>
<li><code>Retrieve()</code>: Return the element at a given position in the list.</li>
<li><code>Length()</code>: Return the number of elements in the list.</li>
</ol>
<p>In addition to these basic operations, a linked list ADT may also support additional operations, such as concatenation (joining two lists together), reversal (reversing the order of the elements in the list), and sorting (arranging the elements in the list in a particular order).</p>
<p>The linked list ADT is often implemented using a class or structure that includes fields for the head and tail of the list, as well as a field for the current position in the list. The class or structure may also include methods for performing the various operations on the list.</p>
<h1 id="implementation-and-usage-of-a-linked-list-in-c">Implementation and Usage of a Linked List in C++</h1>
<h2 id="singly-linked-lists"><a href="#singly-linked-lists" aria-hidden="true" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" fill="#ab2b65" viewBox="0 0 20 20" class="w-5 h-5"><path fill-rule="evenodd" clip-rule="evenodd" d="M9.493 2.853a.75.75 0 00-1.486-.205L7.545 6H4.198a.75.75 0 000 1.5h3.14l-.69 5H3.302a.75.75 0 000 1.5h3.14l-.435 3.148a.75.75 0 001.486.205L7.955 14h2.986l-.434 3.148a.75.75 0 001.486.205L12.456 14h3.346a.75.75 0 000-1.5h-3.14l.69-5h3.346a.75.75 0 000-1.5h-3.14l.435-3.147a.75.75 0 00-1.486-.205L12.045 6H9.059l.434-3.147zM8.852 7.5l-.69 5h2.986l.69-5H8.852z"></path></svg></a>Singly linked lists</h2>
<div class="relative"><pre><code class="language-C++ code-highlight"><span class="code-line">#include &lt;iostream&gt;
</span><span class="code-line">using namespace std;
</span><span class="code-line">
</span><span class="code-line">// Define a Node class that stores an integer value and a reference to the next node.
</span><span class="code-line">class Node {
</span><span class="code-line">public:
</span><span class="code-line">    int data;
</span><span class="code-line">    Node* next;
</span><span class="code-line">
</span><span class="code-line">    // Constructor to create a new node with a given value and no next node.
</span><span class="code-line">    Node(int value) {
</span><span class="code-line">        data = value;
</span><span class="code-line">        next = nullptr;
</span><span class="code-line">    }
</span><span class="code-line">};
</span><span class="code-line">
</span><span class="code-line">// Define a LinkedList class that stores a reference to the head of the list.
</span><span class="code-line">class LinkedList {
</span><span class="code-line">public:
</span><span class="code-line">    Node* head;
</span><span class="code-line">
</span><span class="code-line">    // Constructor to create an empty linked list.
</span><span class="code-line">    LinkedList() {
</span><span class="code-line">        head = nullptr;
</span><span class="code-line">    }
</span><span class="code-line">
</span><span class="code-line">    // Function to insert a new node with a given value at the front of the list.
</span><span class="code-line">    void insertAtFront(int value) {
</span><span class="code-line">        // Create a new node.
</span><span class="code-line">        Node* newNode = new Node(value);
</span><span class="code-line">        // Set the next field of the new node to the current head of the list.
</span><span class="code-line">        newNode-&gt;next = head;
</span><span class="code-line">        // Set the head of the list to the new node.
</span><span class="code-line">        head = newNode;
</span><span class="code-line">    }
</span><span class="code-line">
</span><span class="code-line">    // Function to delete the node at the front of the list.
</span><span class="code-line">    void deleteAtFront() {
</span><span class="code-line">        // If the list is empty, do nothing.
</span><span class="code-line">        if (head == nullptr) {
</span><span class="code-line">            return;
</span><span class="code-line">        }
</span><span class="code-line">        // Save a reference to the head of the list.
</span><span class="code-line">        Node* temp = head;
</span><span class="code-line">        // Set the head of the list to the next node in the list.
</span><span class="code-line">        head = head-&gt;next;
</span><span class="code-line">        // Delete the old head of the list.
</span><span class="code-line">        delete temp;
</span><span class="code-line">    }
</span><span class="code-line">
</span><span class="code-line">    // Function to print the values of all the nodes in the list.
</span><span class="code-line">    void print() {
</span><span class="code-line">        // Start at the head of the list.
</span><span class="code-line">        Node* current = head;
</span><span class="code-line">        // Print the value of each node until we reach the end of the list.
</span><span class="code-line">        while (current != nullptr) {
</span><span class="code-line">            std::cout &lt;&lt; current-&gt;data &lt;&lt; &quot; &quot;;
</span><span class="code-line">            current = current-&gt;next;
</span><span class="code-line">        }
</span><span class="code-line">        std::cout &lt;&lt; std::endl;
</span><span class="code-line">    }
</span><span class="code-line">};
</span><span class="code-line">
</span><span class="code-line">int main() {
</span><span class="code-line">    // Create a new linked list.
</span><span class="code-line">    LinkedList list;
</span><span class="code-line">
</span><span class="code-line">    // Insert some values at the front of the list.
</span><span class="code-line">    list.insertAtFront(3);
</span><span class="code-line">    list.insertAtFront(2);
</span><span class="code-line">    list.insertAtFront(1);
</span><span class="code-line">
</span><span class="code-line">    // Print the values in the list.
</span><span class="code-line">    list.print(); // Output: 1 2 3
</span><span class="code-line">
</span><span class="code-line">    // Delete the first node in the list.
</span><span class="code-line">    list.deleteAtFront();
</span><span class="code-line">
</span><span class="code-line">    // Print the values in the list again.
</span><span class="code-line">    list.print(); // Output: 2 3
</span><span class="code-line">
</span><span class="code-line">    return 0;
</span><span class="code-line">}
</span><span class="code-line">
</span></code></pre></div>
<h2 id="doubly-linked-lists"><a href="#doubly-linked-lists" aria-hidden="true" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" fill="#ab2b65" viewBox="0 0 20 20" class="w-5 h-5"><path fill-rule="evenodd" clip-rule="evenodd" d="M9.493 2.853a.75.75 0 00-1.486-.205L7.545 6H4.198a.75.75 0 000 1.5h3.14l-.69 5H3.302a.75.75 0 000 1.5h3.14l-.435 3.148a.75.75 0 001.486.205L7.955 14h2.986l-.434 3.148a.75.75 0 001.486.205L12.456 14h3.346a.75.75 0 000-1.5h-3.14l.69-5h3.346a.75.75 0 000-1.5h-3.14l.435-3.147a.75.75 0 00-1.486-.205L12.045 6H9.059l.434-3.147zM8.852 7.5l-.69 5h2.986l.69-5H8.852z"></path></svg></a>Doubly Linked Lists</h2>
<div class="relative"><pre><code class="language-C++ code-highlight"><span class="code-line">
</span><span class="code-line">#include &lt;iostream&gt;
</span><span class="code-line">
</span><span class="code-line">// Define a Node class that stores an integer value and references to the next and previous nodes.
</span><span class="code-line">class Node {
</span><span class="code-line">public:
</span><span class="code-line">    int data;
</span><span class="code-line">    Node* next;
</span><span class="code-line">    Node* prev;
</span><span class="code-line">
</span><span class="code-line">    // Constructor to create a new node with a given value and no next or previous nodes.
</span><span class="code-line">    Node(int value) {
</span><span class="code-line">        data = value;
</span><span class="code-line">        next = nullptr;
</span><span class="code-line">        prev = nullptr;
</span><span class="code-line">    }
</span><span class="code-line">};
</span><span class="code-line">
</span><span class="code-line">// Define a LinkedList class that stores a reference to the head and tail of the list.
</span><span class="code-line">class LinkedList {
</span><span class="code-line">public:
</span><span class="code-line">    Node* head;
</span><span class="code-line">    Node* tail;
</span><span class="code-line">
</span><span class="code-line">    // Constructor to create an empty linked list.
</span><span class="code-line">    LinkedList() {
</span><span class="code-line">        head = nullptr;
</span><span class="code-line">        tail = nullptr;
</span><span class="code-line">    }
</span><span class="code-line">
</span><span class="code-line">    // Function to insert a new node with a given value at the front of the list.
</span><span class="code-line">    void insertAtFront(int value) {
</span><span class="code-line">        // Create a new node.
</span><span class="code-line">        Node* newNode = new Node(value);
</span><span class="code-line">        // Set the next field of the new node to the current head of the list.
</span><span class="code-line">        newNode-&gt;next = head;
</span><span class="code-line">        // Set the previous field of the new node to null.
</span><span class="code-line">        newNode-&gt;prev = nullptr;
</span><span class="code-line">        // If the list is not empty, set the previous field of the current head of the list to the new node.
</span><span class="code-line">        if (head != nullptr) {
</span><span class="code-line">            head-&gt;prev = newNode;
</span><span class="code-line">        }
</span><span class="code-line">        // Set the head of the list to the new node.
</span><span class="code-line">        head = newNode;
</span><span class="code-line">        // If the list was previously empty, set the tail of the list to the new node.
</span><span class="code-line">        if (tail == nullptr) {
</span><span class="code-line">            tail = newNode;
</span><span class="code-line">        }
</span><span class="code-line">    }
</span><span class="code-line">
</span><span class="code-line">		// Function to delete the node at the front of the list.
</span><span class="code-line">	void deleteAtFront() {
</span><span class="code-line">	    // If the list is empty, do nothing.
</span><span class="code-line">	    if (head == nullptr) {
</span><span class="code-line">	        return;
</span><span class="code-line">	    }
</span><span class="code-line">	    // Save a reference to the head of the list.
</span><span class="code-line">	    Node* temp = head;
</span><span class="code-line">	    // Set the head of the list to the next node in the list.
</span><span class="code-line">	    head = head-&gt;next;
</span><span class="code-line">	    // If the list is not now empty, set the previous field of the new head of the list to null.
</span><span class="code-line">	    if (head != nullptr) {
</span><span class="code-line">	        head-&gt;prev = nullptr;
</span><span class="code-line">	    }
</span><span class="code-line">	    // If the list is now empty, set the tail of the list to null.
</span><span class="code-line">	    if (head == nullptr) {
</span><span class="code-line">	        tail = nullptr;
</span><span class="code-line">	    }
</span><span class="code-line">	    // Delete the old head of the list.
</span><span class="code-line">	    delete temp;
</span><span class="code-line">	}
</span><span class="code-line">	
</span><span class="code-line">	// Function to insert a new node with a given value at the end of the list.
</span><span class="code-line">	void insertAtEnd(int value) {
</span><span class="code-line">	    // Create a new node.
</span><span class="code-line">	    Node* newNode = new Node(value);
</span><span class="code-line">	    // Set the previous field of the new node to the current tail of the list.
</span><span class="code-line">	    newNode-&gt;prev = tail;
</span><span class="code-line">	    // Set the next field of the new node to null.
</span><span class="code-line">	    newNode-&gt;next = nullptr;
</span><span class="code-line">	    // If the list is not empty, set the next field of the current tail of the list to the new node.
</span><span class="code-line">	    if (tail != nullptr) {
</span><span class="code-line">	        tail-&gt;next = newNode;
</span><span class="code-line">	    }
</span><span class="code-line">	    // Set the tail of the list to the new node.
</span><span class="code-line">	    tail = newNode;
</span><span class="code-line">	    // If the list was previously empty, set the head of the list to the new node.
</span><span class="code-line">	    if (head == nullptr) {
</span><span class="code-line">	        head = newNode;
</span><span class="code-line">	    }
</span><span class="code-line">	}
</span><span class="code-line">	
</span><span class="code-line">	// Function to delete the node at the end of the list.
</span><span class="code-line">	void deleteAtEnd() {
</span><span class="code-line">	    // If the list is empty, do nothing.
</span><span class="code-line">	    if (tail == nullptr) {
</span><span class="code-line">	        return;
</span><span class="code-line">	    }
</span><span class="code-line">	    // Save a reference to the tail of the list.
</span><span class="code-line">	    Node* temp = tail;
</span><span class="code-line">	    // Set the tail of the list to the previous node in the list.
</span><span class="code-line">	    tail = tail-&gt;prev;
</span><span class="code-line">	    // If the list is not now empty, set the next field of the new tail of the list to null.
</span><span class="code-line">	    if (tail != nullptr) {
</span><span class="code-line">	        tail-&gt;next = nullptr;
</span><span class="code-line">	    }
</span><span class="code-line">	    // If the list is now empty, set the head of the list to null.
</span><span class="code-line">	    if (tail == nullptr) {
</span><span class="code-line">	        head = nullptr;
</span><span class="code-line">	    }
</span><span class="code-line">	    // Delete the old tail of the list.
</span><span class="code-line">	    delete temp;
</span><span class="code-line">	}
</span><span class="code-line">
</span><span class="code-line">	// Function to print the values of all the nodes in the list.
</span><span class="code-line">	void print() {
</span><span class="code-line">	    // Start at the head of the list.
</span><span class="code-line">	    Node* current = head;
</span><span class="code-line">	    // Print the value of each node until we reach the end of the list.
</span><span class="code-line">	    while (current != nullptr) {
</span><span class="code-line">	        std::cout &lt;&lt; current-&gt;data &lt;&lt; &quot; &quot;;
</span><span class="code-line">	        current = current-&gt;next;
</span><span class="code-line">	    }
</span><span class="code-line">	    std::cout &lt;&lt; std::endl;
</span><span class="code-line">	}
</span><span class="code-line">	};
</span><span class="code-line">	
</span><span class="code-line">	// Main function to demonstrate the linked list implementation.
</span><span class="code-line">	int main() {
</span><span class="code-line">	    // Create a new linked list.
</span><span class="code-line">	    LinkedList list;
</span><span class="code-line">	    // Insert some values at the front of the list.
</span><span class="code-line">	    list.insertAtFront(1);
</span><span class="code-line">	    list.insertAtFront(2);
</span><span class="code-line">	    list.insertAtFront(3);
</span><span class="code-line">	    // Print the values of the nodes in the list.
</span><span class="code-line">	    std::cout &lt;&lt; &quot;After inserting at front: &quot;;
</span><span class="code-line">	    list.print();
</span><span class="code-line">	    // Insert some values at the end of the list.
</span><span class="code-line">	    list.insertAtEnd(4);
</span><span class="code-line">	    list.insertAtEnd(5);
</span><span class="code-line">	    list.insertAtEnd(6);
</span><span class="code-line">	    // Print the values of the nodes in the list.
</span><span class="code-line">	    std::cout &lt;&lt; &quot;After inserting at end: &quot;;
</span><span class="code-line">	    list.print();
</span><span class="code-line">	    // Delete a node from the front of the list.
</span><span class="code-line">	    list.deleteAtFront();
</span><span class="code-line">	    // Print the values of the nodes in the list.
</span><span class="code-line">	    std::cout &lt;&lt; &quot;After deleting at front: &quot;;
</span><span class="code-line">	    list.print();
</span><span class="code-line">	    // Delete a node from the end of the list.
</span><span class="code-line">	    list.deleteAtEnd();
</span><span class="code-line">	    // Print the values of the nodes in the list.
</span><span class="code-line">	    std::cout &lt;&lt; &quot;After deleting at end: &quot;;
</span><span class="code-line">	    list.print();
</span><span class="code-line">	    return 0;
</span><span class="code-line">	}
</span><span class="code-line">
</span><span class="code-line">
</span></code></pre></div>
<hr/></section></article>;</main></div><footer class="bg-background dark:bg-background-dark prose dark:prose-invert max-w-none flex flex-col items-center justify-center w-full h-auto pt-10 pb-20"><div class="flex w-full flex-wrap justify-center"></div><p class="flex items-center justify-center">Created by<a href="" target="_blank" rel="noopener noreferrer" class="flex items-center no-underline"></a></p><p class="flex items-center justify-center">Made with<a href="https://flowershow.app/" target="_blank" rel="noopener noreferrer" class="flex items-center no-underline"><img src="https://flowershow.app/assets/images/logo.svg" alt="Flowershow" class="my-0 h-6 block"/>Flowershow</a></p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"layout":"docs","data":[],"body":{"raw":"\n# What is a Linked List\n\n- A linked list is a linear data structure in which elements are stored in nodes, and each node has a reference, or a link, to the next node in the list. \n- The first node in a linked list is called the head, and the last node is called the tail. \n- Linked lists can be used to implement many different data structures, such as stacks, queues, and symbol tables. \n- One of the main advantages of linked lists is that they allow for efficient insertion and deletion of elements, since elements can be added or removed by updating the links between the nodes. \n- However, linked lists are not as efficient as arrays for accessing elements by their index, since elements in a linked list must be accessed sequentially starting from the head of the list.\n- There are two main types of linked lists: singly linked lists and doubly linked lists. In a singly linked list, each node has a link to the next node in the list, but not to the previous node. \n- In a doubly linked list, each node has a link to both the next node and the previous node.\n- There are also several variations of linked lists, such as circular linked lists and threaded linked lists. In a circular linked list, the tail node of the list has a link to the head node, forming a loop. \n- In a threaded linked list, nodes may have a link to the next node in the list, as well as a link to the successor in a particular order (such as in-order or pre-order traversal of a tree).\n- Linked lists have several applications, including being used as the underlying data structure for implementing dynamic arrays, which can grow and shrink as needed. \n- They are also commonly used to implement graphs, which consist of nodes and edges connecting them.\n\nOverall, linked lists are a flexible and efficient data structure that is useful in a wide range of applications.\n\n___\n\n# ADT of a Linked List\n\nThe abstract data type (ADT) of a linked list is a linear collection of data elements, in which each element (also called a node) stores a reference to the next element in the list. A linked list ADT can support the following operations:\n\n1.  `Insert()`: Add a new element to the list.\n2.  `Delete()`: Remove an element from the list.\n3.  `Find()`: Search for an element in the list and return its position.\n4.  `Retrieve()`: Return the element at a given position in the list.\n5.  `Length()`: Return the number of elements in the list.\n\nIn addition to these basic operations, a linked list ADT may also support additional operations, such as concatenation (joining two lists together), reversal (reversing the order of the elements in the list), and sorting (arranging the elements in the list in a particular order).\n\nThe linked list ADT is often implemented using a class or structure that includes fields for the head and tail of the list, as well as a field for the current position in the list. The class or structure may also include methods for performing the various operations on the list.\n\n\n# Implementation and Usage of a Linked List in C++\n\n\n## Singly linked lists\n\n```C++\n#include \u003ciostream\u003e\nusing namespace std;\n\n// Define a Node class that stores an integer value and a reference to the next node.\nclass Node {\npublic:\n    int data;\n    Node* next;\n\n    // Constructor to create a new node with a given value and no next node.\n    Node(int value) {\n        data = value;\n        next = nullptr;\n    }\n};\n\n// Define a LinkedList class that stores a reference to the head of the list.\nclass LinkedList {\npublic:\n    Node* head;\n\n    // Constructor to create an empty linked list.\n    LinkedList() {\n        head = nullptr;\n    }\n\n    // Function to insert a new node with a given value at the front of the list.\n    void insertAtFront(int value) {\n        // Create a new node.\n        Node* newNode = new Node(value);\n        // Set the next field of the new node to the current head of the list.\n        newNode-\u003enext = head;\n        // Set the head of the list to the new node.\n        head = newNode;\n    }\n\n    // Function to delete the node at the front of the list.\n    void deleteAtFront() {\n        // If the list is empty, do nothing.\n        if (head == nullptr) {\n            return;\n        }\n        // Save a reference to the head of the list.\n        Node* temp = head;\n        // Set the head of the list to the next node in the list.\n        head = head-\u003enext;\n        // Delete the old head of the list.\n        delete temp;\n    }\n\n    // Function to print the values of all the nodes in the list.\n    void print() {\n        // Start at the head of the list.\n        Node* current = head;\n        // Print the value of each node until we reach the end of the list.\n        while (current != nullptr) {\n            std::cout \u003c\u003c current-\u003edata \u003c\u003c \" \";\n            current = current-\u003enext;\n        }\n        std::cout \u003c\u003c std::endl;\n    }\n};\n\nint main() {\n    // Create a new linked list.\n    LinkedList list;\n\n    // Insert some values at the front of the list.\n    list.insertAtFront(3);\n    list.insertAtFront(2);\n    list.insertAtFront(1);\n\n    // Print the values in the list.\n    list.print(); // Output: 1 2 3\n\n    // Delete the first node in the list.\n    list.deleteAtFront();\n\n    // Print the values in the list again.\n    list.print(); // Output: 2 3\n\n    return 0;\n}\n\n```\n\n\n## Doubly Linked Lists\n\n```C++\n\n#include \u003ciostream\u003e\n\n// Define a Node class that stores an integer value and references to the next and previous nodes.\nclass Node {\npublic:\n    int data;\n    Node* next;\n    Node* prev;\n\n    // Constructor to create a new node with a given value and no next or previous nodes.\n    Node(int value) {\n        data = value;\n        next = nullptr;\n        prev = nullptr;\n    }\n};\n\n// Define a LinkedList class that stores a reference to the head and tail of the list.\nclass LinkedList {\npublic:\n    Node* head;\n    Node* tail;\n\n    // Constructor to create an empty linked list.\n    LinkedList() {\n        head = nullptr;\n        tail = nullptr;\n    }\n\n    // Function to insert a new node with a given value at the front of the list.\n    void insertAtFront(int value) {\n        // Create a new node.\n        Node* newNode = new Node(value);\n        // Set the next field of the new node to the current head of the list.\n        newNode-\u003enext = head;\n        // Set the previous field of the new node to null.\n        newNode-\u003eprev = nullptr;\n        // If the list is not empty, set the previous field of the current head of the list to the new node.\n        if (head != nullptr) {\n            head-\u003eprev = newNode;\n        }\n        // Set the head of the list to the new node.\n        head = newNode;\n        // If the list was previously empty, set the tail of the list to the new node.\n        if (tail == nullptr) {\n            tail = newNode;\n        }\n    }\n\n\t\t// Function to delete the node at the front of the list.\n\tvoid deleteAtFront() {\n\t    // If the list is empty, do nothing.\n\t    if (head == nullptr) {\n\t        return;\n\t    }\n\t    // Save a reference to the head of the list.\n\t    Node* temp = head;\n\t    // Set the head of the list to the next node in the list.\n\t    head = head-\u003enext;\n\t    // If the list is not now empty, set the previous field of the new head of the list to null.\n\t    if (head != nullptr) {\n\t        head-\u003eprev = nullptr;\n\t    }\n\t    // If the list is now empty, set the tail of the list to null.\n\t    if (head == nullptr) {\n\t        tail = nullptr;\n\t    }\n\t    // Delete the old head of the list.\n\t    delete temp;\n\t}\n\t\n\t// Function to insert a new node with a given value at the end of the list.\n\tvoid insertAtEnd(int value) {\n\t    // Create a new node.\n\t    Node* newNode = new Node(value);\n\t    // Set the previous field of the new node to the current tail of the list.\n\t    newNode-\u003eprev = tail;\n\t    // Set the next field of the new node to null.\n\t    newNode-\u003enext = nullptr;\n\t    // If the list is not empty, set the next field of the current tail of the list to the new node.\n\t    if (tail != nullptr) {\n\t        tail-\u003enext = newNode;\n\t    }\n\t    // Set the tail of the list to the new node.\n\t    tail = newNode;\n\t    // If the list was previously empty, set the head of the list to the new node.\n\t    if (head == nullptr) {\n\t        head = newNode;\n\t    }\n\t}\n\t\n\t// Function to delete the node at the end of the list.\n\tvoid deleteAtEnd() {\n\t    // If the list is empty, do nothing.\n\t    if (tail == nullptr) {\n\t        return;\n\t    }\n\t    // Save a reference to the tail of the list.\n\t    Node* temp = tail;\n\t    // Set the tail of the list to the previous node in the list.\n\t    tail = tail-\u003eprev;\n\t    // If the list is not now empty, set the next field of the new tail of the list to null.\n\t    if (tail != nullptr) {\n\t        tail-\u003enext = nullptr;\n\t    }\n\t    // If the list is now empty, set the head of the list to null.\n\t    if (tail == nullptr) {\n\t        head = nullptr;\n\t    }\n\t    // Delete the old tail of the list.\n\t    delete temp;\n\t}\n\n\t// Function to print the values of all the nodes in the list.\n\tvoid print() {\n\t    // Start at the head of the list.\n\t    Node* current = head;\n\t    // Print the value of each node until we reach the end of the list.\n\t    while (current != nullptr) {\n\t        std::cout \u003c\u003c current-\u003edata \u003c\u003c \" \";\n\t        current = current-\u003enext;\n\t    }\n\t    std::cout \u003c\u003c std::endl;\n\t}\n\t};\n\t\n\t// Main function to demonstrate the linked list implementation.\n\tint main() {\n\t    // Create a new linked list.\n\t    LinkedList list;\n\t    // Insert some values at the front of the list.\n\t    list.insertAtFront(1);\n\t    list.insertAtFront(2);\n\t    list.insertAtFront(3);\n\t    // Print the values of the nodes in the list.\n\t    std::cout \u003c\u003c \"After inserting at front: \";\n\t    list.print();\n\t    // Insert some values at the end of the list.\n\t    list.insertAtEnd(4);\n\t    list.insertAtEnd(5);\n\t    list.insertAtEnd(6);\n\t    // Print the values of the nodes in the list.\n\t    std::cout \u003c\u003c \"After inserting at end: \";\n\t    list.print();\n\t    // Delete a node from the front of the list.\n\t    list.deleteAtFront();\n\t    // Print the values of the nodes in the list.\n\t    std::cout \u003c\u003c \"After deleting at front: \";\n\t    list.print();\n\t    // Delete a node from the end of the list.\n\t    list.deleteAtEnd();\n\t    // Print the values of the nodes in the list.\n\t    std::cout \u003c\u003c \"After deleting at end: \";\n\t    list.print();\n\t    return 0;\n\t}\n\n\n```\n\n___\n","code":"var Component=(()=\u003e{var r=Object.create;var i=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var N=Object.getPrototypeOf,u=Object.prototype.hasOwnProperty;var f=(l,e)=\u003e()=\u003e(e||l((e={exports:{}}).exports,e),e.exports),v=(l,e)=\u003e{for(var a in e)i(l,a,{get:e[a],enumerable:!0})},c=(l,e,a,t)=\u003e{if(e\u0026\u0026typeof e==\"object\"||typeof e==\"function\")for(let s of m(e))!u.call(l,s)\u0026\u0026s!==a\u0026\u0026i(l,s,{get:()=\u003ee[s],enumerable:!(t=p(e,s))||t.enumerable});return l};var w=(l,e,a)=\u003e(a=l!=null?r(N(l)):{},c(e||!l||!l.__esModule?i(a,\"default\",{value:l,enumerable:!0}):a,l)),g=l=\u003ec(i({},\"__esModule\",{value:!0}),l);var o=f((b,d)=\u003e{d.exports=_jsx_runtime});var y={};v(y,{default:()=\u003ex});var n=w(o());function h(l){let e=Object.assign({h1:\"h1\",ul:\"ul\",li:\"li\",p:\"p\",hr:\"hr\",ol:\"ol\",code:\"code\",h2:\"h2\",a:\"a\",svg:\"svg\",path:\"path\",pre:\"pre\",span:\"span\"},l.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h1,{id:\"what-is-a-linked-list\",children:\"What is a Linked List\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"A linked list is a linear data structure in which elements are stored in nodes, and each node has a reference, or a link, to the next node in the list.\"}),`\n`,(0,n.jsx)(e.li,{children:\"The first node in a linked list is called the head, and the last node is called the tail.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Linked lists can be used to implement many different data structures, such as stacks, queues, and symbol tables.\"}),`\n`,(0,n.jsx)(e.li,{children:\"One of the main advantages of linked lists is that they allow for efficient insertion and deletion of elements, since elements can be added or removed by updating the links between the nodes.\"}),`\n`,(0,n.jsx)(e.li,{children:\"However, linked lists are not as efficient as arrays for accessing elements by their index, since elements in a linked list must be accessed sequentially starting from the head of the list.\"}),`\n`,(0,n.jsx)(e.li,{children:\"There are two main types of linked lists: singly linked lists and doubly linked lists. In a singly linked list, each node has a link to the next node in the list, but not to the previous node.\"}),`\n`,(0,n.jsx)(e.li,{children:\"In a doubly linked list, each node has a link to both the next node and the previous node.\"}),`\n`,(0,n.jsx)(e.li,{children:\"There are also several variations of linked lists, such as circular linked lists and threaded linked lists. In a circular linked list, the tail node of the list has a link to the head node, forming a loop.\"}),`\n`,(0,n.jsx)(e.li,{children:\"In a threaded linked list, nodes may have a link to the next node in the list, as well as a link to the successor in a particular order (such as in-order or pre-order traversal of a tree).\"}),`\n`,(0,n.jsx)(e.li,{children:\"Linked lists have several applications, including being used as the underlying data structure for implementing dynamic arrays, which can grow and shrink as needed.\"}),`\n`,(0,n.jsx)(e.li,{children:\"They are also commonly used to implement graphs, which consist of nodes and edges connecting them.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Overall, linked lists are a flexible and efficient data structure that is useful in a wide range of applications.\"}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h1,{id:\"adt-of-a-linked-list\",children:\"ADT of a Linked List\"}),`\n`,(0,n.jsx)(e.p,{children:\"The abstract data type (ADT) of a linked list is a linear collection of data elements, in which each element (also called a node) stores a reference to the next element in the list. A linked list ADT can support the following operations:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"Insert()\"}),\": Add a new element to the list.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"Delete()\"}),\": Remove an element from the list.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"Find()\"}),\": Search for an element in the list and return its position.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"Retrieve()\"}),\": Return the element at a given position in the list.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"Length()\"}),\": Return the number of elements in the list.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"In addition to these basic operations, a linked list ADT may also support additional operations, such as concatenation (joining two lists together), reversal (reversing the order of the elements in the list), and sorting (arranging the elements in the list in a particular order).\"}),`\n`,(0,n.jsx)(e.p,{children:\"The linked list ADT is often implemented using a class or structure that includes fields for the head and tail of the list, as well as a field for the current position in the list. The class or structure may also include methods for performing the various operations on the list.\"}),`\n`,(0,n.jsx)(e.h1,{id:\"implementation-and-usage-of-a-linked-list-in-c\",children:\"Implementation and Usage of a Linked List in C++\"}),`\n`,(0,n.jsxs)(e.h2,{id:\"singly-linked-lists\",children:[(0,n.jsx)(e.a,{\"aria-hidden\":\"true\",tabIndex:\"-1\",href:\"#singly-linked-lists\",children:(0,n.jsx)(e.svg,{xmlns:\"http://www.w3.org/2000/svg\",fill:\"#ab2b65\",viewBox:\"0 0 20 20\",className:\"w-5 h-5\",children:(0,n.jsx)(e.path,{fillRule:\"evenodd\",clipRule:\"evenodd\",d:\"M9.493 2.853a.75.75 0 00-1.486-.205L7.545 6H4.198a.75.75 0 000 1.5h3.14l-.69 5H3.302a.75.75 0 000 1.5h3.14l-.435 3.148a.75.75 0 001.486.205L7.955 14h2.986l-.434 3.148a.75.75 0 001.486.205L12.456 14h3.346a.75.75 0 000-1.5h-3.14l.69-5h3.346a.75.75 0 000-1.5h-3.14l.435-3.147a.75.75 0 00-1.486-.205L12.045 6H9.059l.434-3.147zM8.852 7.5l-.69 5h2.986l.69-5H8.852z\"})})}),\"Singly linked lists\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"language-C++ code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`#include \u003ciostream\u003e\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`using namespace std;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Define a Node class that stores an integer value and a reference to the next node.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`class Node {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`public:\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    int data;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    Node* next;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Constructor to create a new node with a given value and no next node.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    Node(int value) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        data = value;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        next = nullptr;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`};\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Define a LinkedList class that stores a reference to the head of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`class LinkedList {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`public:\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    Node* head;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Constructor to create an empty linked list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    LinkedList() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        head = nullptr;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Function to insert a new node with a given value at the front of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    void insertAtFront(int value) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        // Create a new node.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        Node* newNode = new Node(value);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        // Set the next field of the new node to the current head of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        newNode-\u003enext = head;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        // Set the head of the list to the new node.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        head = newNode;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Function to delete the node at the front of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    void deleteAtFront() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        // If the list is empty, do nothing.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        if (head == nullptr) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            return;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        // Save a reference to the head of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        Node* temp = head;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        // Set the head of the list to the next node in the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        head = head-\u003enext;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        // Delete the old head of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        delete temp;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Function to print the values of all the nodes in the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    void print() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        // Start at the head of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        Node* current = head;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        // Print the value of each node until we reach the end of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        while (current != nullptr) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            std::cout \u003c\u003c current-\u003edata \u003c\u003c \" \";\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            current = current-\u003enext;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        std::cout \u003c\u003c std::endl;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`};\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`int main() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Create a new linked list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    LinkedList list;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Insert some values at the front of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    list.insertAtFront(3);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    list.insertAtFront(2);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    list.insertAtFront(1);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Print the values in the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    list.print(); // Output: 1 2 3\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Delete the first node in the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    list.deleteAtFront();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Print the values in the list again.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    list.print(); // Output: 2 3\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    return 0;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`})]})}),`\n`,(0,n.jsxs)(e.h2,{id:\"doubly-linked-lists\",children:[(0,n.jsx)(e.a,{\"aria-hidden\":\"true\",tabIndex:\"-1\",href:\"#doubly-linked-lists\",children:(0,n.jsx)(e.svg,{xmlns:\"http://www.w3.org/2000/svg\",fill:\"#ab2b65\",viewBox:\"0 0 20 20\",className:\"w-5 h-5\",children:(0,n.jsx)(e.path,{fillRule:\"evenodd\",clipRule:\"evenodd\",d:\"M9.493 2.853a.75.75 0 00-1.486-.205L7.545 6H4.198a.75.75 0 000 1.5h3.14l-.69 5H3.302a.75.75 0 000 1.5h3.14l-.435 3.148a.75.75 0 001.486.205L7.955 14h2.986l-.434 3.148a.75.75 0 001.486.205L12.456 14h3.346a.75.75 0 000-1.5h-3.14l.69-5h3.346a.75.75 0 000-1.5h-3.14l.435-3.147a.75.75 0 00-1.486-.205L12.045 6H9.059l.434-3.147zM8.852 7.5l-.69 5h2.986l.69-5H8.852z\"})})}),\"Doubly Linked Lists\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"language-C++ code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`#include \u003ciostream\u003e\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Define a Node class that stores an integer value and references to the next and previous nodes.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`class Node {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`public:\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    int data;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    Node* next;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    Node* prev;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Constructor to create a new node with a given value and no next or previous nodes.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    Node(int value) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        data = value;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        next = nullptr;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        prev = nullptr;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`};\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// Define a LinkedList class that stores a reference to the head and tail of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`class LinkedList {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`public:\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    Node* head;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    Node* tail;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Constructor to create an empty linked list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    LinkedList() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        head = nullptr;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        tail = nullptr;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Function to insert a new node with a given value at the front of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    void insertAtFront(int value) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        // Create a new node.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        Node* newNode = new Node(value);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        // Set the next field of the new node to the current head of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        newNode-\u003enext = head;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        // Set the previous field of the new node to null.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        newNode-\u003eprev = nullptr;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        // If the list is not empty, set the previous field of the current head of the list to the new node.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        if (head != nullptr) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            head-\u003eprev = newNode;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        // Set the head of the list to the new node.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        head = newNode;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        // If the list was previously empty, set the tail of the list to the new node.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        if (tail == nullptr) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            tail = newNode;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t\t// Function to delete the node at the front of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\tvoid deleteAtFront() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // If the list is empty, do nothing.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    if (head == nullptr) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t        return;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // Save a reference to the head of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    Node* temp = head;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // Set the head of the list to the next node in the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    head = head-\u003enext;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // If the list is not now empty, set the previous field of the new head of the list to null.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    if (head != nullptr) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t        head-\u003eprev = nullptr;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // If the list is now empty, set the tail of the list to null.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    if (head == nullptr) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t        tail = nullptr;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // Delete the old head of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    delete temp;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t// Function to insert a new node with a given value at the end of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\tvoid insertAtEnd(int value) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // Create a new node.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    Node* newNode = new Node(value);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // Set the previous field of the new node to the current tail of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    newNode-\u003eprev = tail;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // Set the next field of the new node to null.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    newNode-\u003enext = nullptr;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // If the list is not empty, set the next field of the current tail of the list to the new node.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    if (tail != nullptr) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t        tail-\u003enext = newNode;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // Set the tail of the list to the new node.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    tail = newNode;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // If the list was previously empty, set the head of the list to the new node.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    if (head == nullptr) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t        head = newNode;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t// Function to delete the node at the end of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\tvoid deleteAtEnd() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // If the list is empty, do nothing.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    if (tail == nullptr) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t        return;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // Save a reference to the tail of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    Node* temp = tail;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // Set the tail of the list to the previous node in the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    tail = tail-\u003eprev;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // If the list is not now empty, set the next field of the new tail of the list to null.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    if (tail != nullptr) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t        tail-\u003enext = nullptr;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // If the list is now empty, set the head of the list to null.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    if (tail == nullptr) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t        head = nullptr;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // Delete the old tail of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    delete temp;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t// Function to print the values of all the nodes in the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\tvoid print() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // Start at the head of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    Node* current = head;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // Print the value of each node until we reach the end of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    while (current != nullptr) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t        std::cout \u003c\u003c current-\u003edata \u003c\u003c \" \";\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t        current = current-\u003enext;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    std::cout \u003c\u003c std::endl;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t};\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t// Main function to demonstrate the linked list implementation.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\tint main() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // Create a new linked list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    LinkedList list;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // Insert some values at the front of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    list.insertAtFront(1);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    list.insertAtFront(2);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    list.insertAtFront(3);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // Print the values of the nodes in the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    std::cout \u003c\u003c \"After inserting at front: \";\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    list.print();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // Insert some values at the end of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    list.insertAtEnd(4);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    list.insertAtEnd(5);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    list.insertAtEnd(6);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // Print the values of the nodes in the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    std::cout \u003c\u003c \"After inserting at end: \";\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    list.print();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // Delete a node from the front of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    list.deleteAtFront();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // Print the values of the nodes in the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    std::cout \u003c\u003c \"After deleting at front: \";\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    list.print();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // Delete a node from the end of the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    list.deleteAtEnd();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    // Print the values of the nodes in the list.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    std::cout \u003c\u003c \"After deleting at end: \";\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    list.print();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t    return 0;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\t}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`})]})}),`\n`,(0,n.jsx)(e.hr,{})]})}function k(l={}){let{wrapper:e}=l.components||{};return e?(0,n.jsx)(e,Object.assign({},l,{children:(0,n.jsx)(h,l)})):h(l)}var x=k;return g(y);})();\n;return Component;"},"_id":"College/Sem IV/Content/Linked Lists.md","_raw":{"sourceFilePath":"College/Sem IV/Content/Linked Lists.md","sourceFileName":"Linked Lists.md","sourceFileDir":"College/Sem IV/Content","contentType":"markdown","flattenedPath":"College/Sem IV/Content/Linked Lists"},"type":"Page","url_path":"College/Sem IV/Content/Linked Lists","slug":"Linked Lists","authorsDetails":[],"globals":{}},"__N_SSG":true},"page":"/[[...slug]]","query":{"slug":["College","Sem IV","Content","Linked Lists"]},"buildId":"dx8-lOgzMavXNxsNaqq0-","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>